<Type Name="DbSet&lt;TEntity&gt;" FullName="Microsoft.EntityFrameworkCore.DbSet&lt;TEntity&gt;">
  <TypeSignature Language="C#" Value="public abstract class DbSet&lt;TEntity&gt; : Microsoft.EntityFrameworkCore.Infrastructure.IInfrastructure&lt;IServiceProvider&gt;, Microsoft.EntityFrameworkCore.Query.Internal.IAsyncEnumerableAccessor&lt;TEntity&gt;, System.Collections.Generic.IEnumerable&lt;TEntity&gt;, System.ComponentModel.IListSource, System.Linq.IQueryable, System.Linq.IQueryable&lt;TEntity&gt; where TEntity : class" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit DbSet`1&lt;class TEntity&gt; extends System.Object implements class Microsoft.EntityFrameworkCore.Infrastructure.IInfrastructure`1&lt;class System.IServiceProvider&gt;, class Microsoft.EntityFrameworkCore.Query.Internal.IAsyncEnumerableAccessor`1&lt;!TEntity&gt;, class System.Collections.Generic.IEnumerable`1&lt;!TEntity&gt;, class System.Collections.IEnumerable, class System.ComponentModel.IListSource, class System.Linq.IQueryable, class System.Linq.IQueryable`1&lt;!TEntity&gt;" />
  <TypeSignature Language="DocId" Value="T:Microsoft.EntityFrameworkCore.DbSet`1" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class DbSet(Of TEntity)&#xA;Implements IAsyncEnumerableAccessor(Of TEntity), IEnumerable(Of TEntity), IInfrastructure(Of IServiceProvider), IListSource, IQueryable, IQueryable(Of TEntity)" />
  <TypeSignature Language="F#" Value="type DbSet&lt;'Entity (requires 'Entity : null)&gt; = class&#xA;    interface IQueryable&lt;'Entity (requires 'Entity : null)&gt;&#xA;    interface seq&lt;'Entity (requires 'Entity : null)&gt;&#xA;    interface IEnumerable&#xA;    interface IQueryable&#xA;    interface IAsyncEnumerableAccessor&lt;'Entity (requires 'Entity : null)&gt;&#xA;    interface IInfrastructure&lt;IServiceProvider&gt;&#xA;    interface IListSource" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TEntity">
      <Constraints>
        <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
      </Constraints>
    </TypeParameter>
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Infrastructure.IInfrastructure&lt;System.IServiceProvider&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Microsoft.EntityFrameworkCore.Query.Internal.IAsyncEnumerableAccessor&lt;TEntity&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;TEntity&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.IListSource</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Linq.IQueryable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Linq.IQueryable&lt;TEntity&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <typeparam name="TEntity"> The type of entity being operated on by this set. </typeparam>
    <summary>
      <para>
                    A <see cref="T:Microsoft.EntityFrameworkCore.DbSet`1" /> can be used to query and save instances of <typeparamref name="TEntity" />.
                    LINQ queries against a <see cref="T:Microsoft.EntityFrameworkCore.DbSet`1" /> will be translated into queries against the database.
                </para>
      <para>
                    The results of a LINQ query against a <see cref="T:Microsoft.EntityFrameworkCore.DbSet`1" /> will contain the results
                    returned from the database and may not reflect changes made in the context that have not
                    been persisted to the database. For example, the results will not contain newly added entities
                    and may still contain entities that are marked for deletion.
                </para>
      <para>
                    Depending on the database being used, some parts of a LINQ query against a <see cref="T:Microsoft.EntityFrameworkCore.DbSet`1" />
                    may be evaluated in memory rather than being translated into a database query.
                </para>
      <para>
        <see cref="T:Microsoft.EntityFrameworkCore.DbSet`1" /> objects are usually obtained from a <see cref="T:Microsoft.EntityFrameworkCore.DbSet`1" />
                    property on a derived <see cref="T:Microsoft.EntityFrameworkCore.DbContext" /> or from the <see cref="M:Microsoft.EntityFrameworkCore.DbContext.Set``1" />
                    method.
                </para>
    </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DbSet ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.DbSet`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.ChangeTracking.EntityEntry&lt;TEntity&gt; Add (TEntity entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.ChangeTracking.EntityEntry`1&lt;!TEntity&gt; Add(!TEntity entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.DbSet`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (entity As TEntity) As EntityEntry(Of TEntity)" />
      <MemberSignature Language="F#" Value="abstract member Add : 'Entity -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.EntityEntry&lt;'Entity (requires 'Entity : null)&gt;&#xA;override this.Add : 'Entity -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.EntityEntry&lt;'Entity (requires 'Entity : null)&gt;" Usage="dbSet.Add entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.EntityEntry&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
      </Parameters>
      <Docs>
        <param name="entity"> The entity to add. </param>
        <summary>
          <para>
                    Begins tracking the given entity, and any other reachable entities that are
                    not already being tracked, in the <see cref="F:Microsoft.EntityFrameworkCore.EntityState.Added" /> state such that they will
                    be inserted into the database when <see cref="M:Microsoft.EntityFrameworkCore.DbContext.SaveChanges" /> is called.
                </para>
          <para>
                    Use <see cref="P:Microsoft.EntityFrameworkCore.ChangeTracking.EntityEntry.State" /> to set the state of only a single entity.
                </para>
        </summary>
        <returns>
                The <see cref="T:Microsoft.EntityFrameworkCore.ChangeTracking.EntityEntry`1" /> for the entity. The entry provides
                access to change tracking information and operations for the entity.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Microsoft.EntityFrameworkCore.ChangeTracking.EntityEntry&lt;TEntity&gt;&gt; AddAsync (TEntity entity, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Microsoft.EntityFrameworkCore.ChangeTracking.EntityEntry`1&lt;!TEntity&gt;&gt; AddAsync(!TEntity entity, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.DbSet`1.AddAsync(`0,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member AddAsync : 'Entity * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Microsoft.EntityFrameworkCore.ChangeTracking.EntityEntry&lt;'Entity&gt;&gt;&#xA;override this.AddAsync : 'Entity * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Microsoft.EntityFrameworkCore.ChangeTracking.EntityEntry&lt;'Entity&gt;&gt;" Usage="dbSet.AddAsync (entity, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Microsoft.EntityFrameworkCore.ChangeTracking.EntityEntry&lt;TEntity&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="entity"> The entity to add. </param>
        <param name="cancellationToken">A <see cref="T:System.Threading.CancellationToken" /> to observe while waiting for the task to complete.</param>
        <summary>
          <para>
                    Begins tracking the given entity, and any other reachable entities that are
                    not already being tracked, in the <see cref="F:Microsoft.EntityFrameworkCore.EntityState.Added" /> state such that they will
                    be inserted into the database when <see cref="M:Microsoft.EntityFrameworkCore.DbContext.SaveChanges" /> is called.
                </para>
          <para>
                    This method is async only to allow special value generators, such as the one used by
                    'Microsoft.EntityFrameworkCore.Metadata.SqlServerValueGenerationStrategy.SequenceHiLo',
                    to access the database asynchronously. For all other cases the non async method should be used.
                </para>
          <para>
                    Use <see cref="P:Microsoft.EntityFrameworkCore.ChangeTracking.EntityEntry.State" /> to set the state of only a single entity.
                </para>
        </summary>
        <returns>
                A task that represents the asynchronous Add operation. The task result contains the
                <see cref="T:Microsoft.EntityFrameworkCore.ChangeTracking.EntityEntry`1" /> for the entity. The entry provides access to change tracking
                information and operations for the entity.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public virtual void AddRange (System.Collections.Generic.IEnumerable&lt;TEntity&gt; entities);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddRange(class System.Collections.Generic.IEnumerable`1&lt;!TEntity&gt; entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.DbSet`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AddRange (entities As IEnumerable(Of TEntity))" />
      <MemberSignature Language="F#" Value="abstract member AddRange : seq&lt;'Entity (requires 'Entity : null)&gt; -&gt; unit&#xA;override this.AddRange : seq&lt;'Entity (requires 'Entity : null)&gt; -&gt; unit" Usage="dbSet.AddRange entities" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entities" Type="System.Collections.Generic.IEnumerable&lt;TEntity&gt;" />
      </Parameters>
      <Docs>
        <param name="entities"> The entities to add. </param>
        <summary>
                Begins tracking the given entities, and any other reachable entities that are
                not already being tracked, in the <see cref="F:Microsoft.EntityFrameworkCore.EntityState.Added" /> state such that they will
                be inserted into the database when <see cref="M:Microsoft.EntityFrameworkCore.DbContext.SaveChanges" /> is called.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public virtual void AddRange (params TEntity[] entities);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddRange(!TEntity[] entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.DbSet`1.AddRange(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AddRange (ParamArray entities As TEntity())" />
      <MemberSignature Language="F#" Value="abstract member AddRange : 'Entity[] -&gt; unit&#xA;override this.AddRange : 'Entity[] -&gt; unit" Usage="dbSet.AddRange entities" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entities" Type="TEntity[]">
          <Attributes>
            <Attribute FrameworkAlternate="aspnetcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="entities"> The entities to add. </param>
        <summary>
                Begins tracking the given entities, and any other reachable entities that are
                not already being tracked, in the <see cref="F:Microsoft.EntityFrameworkCore.EntityState.Added" /> state such that they will
                be inserted into the database when <see cref="M:Microsoft.EntityFrameworkCore.DbContext.SaveChanges" /> is called.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddRangeAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AddRangeAsync (params TEntity[] entities);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AddRangeAsync(!TEntity[] entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.DbSet`1.AddRangeAsync(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddRangeAsync (ParamArray entities As TEntity()) As Task" />
      <MemberSignature Language="F#" Value="abstract member AddRangeAsync : 'Entity[] -&gt; System.Threading.Tasks.Task&#xA;override this.AddRangeAsync : 'Entity[] -&gt; System.Threading.Tasks.Task" Usage="dbSet.AddRangeAsync entities" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entities" Type="TEntity[]">
          <Attributes>
            <Attribute FrameworkAlternate="aspnetcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="entities"> The entities to add. </param>
        <summary>
          <para>
                    Begins tracking the given entities, and any other reachable entities that are
                    not already being tracked, in the <see cref="F:Microsoft.EntityFrameworkCore.EntityState.Added" /> state such that they will
                    be inserted into the database when <see cref="M:Microsoft.EntityFrameworkCore.DbContext.SaveChanges" /> is called.
                </para>
          <para>
                    This method is async only to allow special value generators, such as the one used by
                    'Microsoft.EntityFrameworkCore.Metadata.SqlServerValueGenerationStrategy.SequenceHiLo',
                    to access the database asynchronously. For all other cases the non async method should be used.
                </para>
        </summary>
        <returns> A task that represents the asynchronous operation. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddRangeAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AddRangeAsync (System.Collections.Generic.IEnumerable&lt;TEntity&gt; entities, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AddRangeAsync(class System.Collections.Generic.IEnumerable`1&lt;!TEntity&gt; entities, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.DbSet`1.AddRangeAsync(System.Collections.Generic.IEnumerable{`0},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member AddRangeAsync : seq&lt;'Entity (requires 'Entity : null)&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&#xA;override this.AddRangeAsync : seq&lt;'Entity (requires 'Entity : null)&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="dbSet.AddRangeAsync (entities, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entities" Type="System.Collections.Generic.IEnumerable&lt;TEntity&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="entities"> The entities to add. </param>
        <param name="cancellationToken">A <see cref="T:System.Threading.CancellationToken" /> to observe while waiting for the task to complete.</param>
        <summary>
          <para>
                    Begins tracking the given entities, and any other reachable entities that are
                    not already being tracked, in the <see cref="F:Microsoft.EntityFrameworkCore.EntityState.Added" /> state such that they will
                    be inserted into the database when <see cref="M:Microsoft.EntityFrameworkCore.DbContext.SaveChanges" /> is called.
                </para>
          <para>
                    This method is async only to allow special value generators, such as the one used by
                    'Microsoft.EntityFrameworkCore.Metadata.SqlServerValueGenerationStrategy.SequenceHiLo',
                    to access the database asynchronously. For all other cases the non async method should be used.
                </para>
        </summary>
        <returns> A task that represents the asynchronous operation. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Attach">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.ChangeTracking.EntityEntry&lt;TEntity&gt; Attach (TEntity entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.ChangeTracking.EntityEntry`1&lt;!TEntity&gt; Attach(!TEntity entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.DbSet`1.Attach(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Attach (entity As TEntity) As EntityEntry(Of TEntity)" />
      <MemberSignature Language="F#" Value="abstract member Attach : 'Entity -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.EntityEntry&lt;'Entity (requires 'Entity : null)&gt;&#xA;override this.Attach : 'Entity -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.EntityEntry&lt;'Entity (requires 'Entity : null)&gt;" Usage="dbSet.Attach entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.EntityEntry&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
      </Parameters>
      <Docs>
        <param name="entity"> The entity to attach. </param>
        <summary>
          <para>
                    Begins tracking the given entity in the <see cref="F:Microsoft.EntityFrameworkCore.EntityState.Unchanged" /> state
                    such that no operation will be performed when <see cref="M:Microsoft.EntityFrameworkCore.DbContext.SaveChanges" />
                    is called.
                </para>
          <para>
                    A recursive search of the navigation properties will be performed to find reachable entities
                    that are not already being tracked by the context. These entities will also begin to be tracked
                    by the context. If a reachable entity has its primary key value set
                    then it will be tracked in the <see cref="F:Microsoft.EntityFrameworkCore.EntityState.Unchanged" /> state. If the primary key
                    value is not set then it will be tracked in the <see cref="F:Microsoft.EntityFrameworkCore.EntityState.Added" /> state.
                    An entity is considered to have its primary key value set if the primary key property is set
                    to anything other than the CLR default for the property type.
                </para>
          <para>
                    Use <see cref="P:Microsoft.EntityFrameworkCore.ChangeTracking.EntityEntry.State" /> to set the state of only a single entity.
                </para>
        </summary>
        <returns>
                The <see cref="T:Microsoft.EntityFrameworkCore.ChangeTracking.EntityEntry" /> for the entity. The entry provides
                access to change tracking information and operations for the entity.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AttachRange">
      <MemberSignature Language="C#" Value="public virtual void AttachRange (System.Collections.Generic.IEnumerable&lt;TEntity&gt; entities);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AttachRange(class System.Collections.Generic.IEnumerable`1&lt;!TEntity&gt; entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.DbSet`1.AttachRange(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AttachRange (entities As IEnumerable(Of TEntity))" />
      <MemberSignature Language="F#" Value="abstract member AttachRange : seq&lt;'Entity (requires 'Entity : null)&gt; -&gt; unit&#xA;override this.AttachRange : seq&lt;'Entity (requires 'Entity : null)&gt; -&gt; unit" Usage="dbSet.AttachRange entities" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entities" Type="System.Collections.Generic.IEnumerable&lt;TEntity&gt;" />
      </Parameters>
      <Docs>
        <param name="entities"> The entities to attach. </param>
        <summary>
          <para>
                    Begins tracking the given entities in the <see cref="F:Microsoft.EntityFrameworkCore.EntityState.Unchanged" /> state
                    such that no operation will be performed when <see cref="M:Microsoft.EntityFrameworkCore.DbContext.SaveChanges" />
                    is called.
                </para>
          <para>
                    A recursive search of the navigation properties will be performed to find reachable entities
                    that are not already being tracked by the context. These entities will also begin to be tracked
                    by the context. If a reachable entity has its primary key value set
                    then it will be tracked in the <see cref="F:Microsoft.EntityFrameworkCore.EntityState.Unchanged" /> state. If the primary key
                    value is not set then it will be tracked in the <see cref="F:Microsoft.EntityFrameworkCore.EntityState.Added" /> state.
                    An entity is considered to have its primary key value set if the primary key property is set
                    to anything other than the CLR default for the property type.
                </para>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AttachRange">
      <MemberSignature Language="C#" Value="public virtual void AttachRange (params TEntity[] entities);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AttachRange(!TEntity[] entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.DbSet`1.AttachRange(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AttachRange (ParamArray entities As TEntity())" />
      <MemberSignature Language="F#" Value="abstract member AttachRange : 'Entity[] -&gt; unit&#xA;override this.AttachRange : 'Entity[] -&gt; unit" Usage="dbSet.AttachRange entities" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entities" Type="TEntity[]">
          <Attributes>
            <Attribute FrameworkAlternate="aspnetcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="entities"> The entities to attach. </param>
        <summary>
          <para>
                    Begins tracking the given entities in the <see cref="F:Microsoft.EntityFrameworkCore.EntityState.Unchanged" /> state
                    such that no operation will be performed when <see cref="M:Microsoft.EntityFrameworkCore.DbContext.SaveChanges" />
                    is called.
                </para>
          <para>
                    A recursive search of the navigation properties will be performed to find reachable entities
                    that are not already being tracked by the context. These entities will also begin to be tracked
                    by the context. If a reachable entity has its primary key value set
                    then it will be tracked in the <see cref="F:Microsoft.EntityFrameworkCore.EntityState.Unchanged" /> state. If the primary key
                    value is not set then it will be tracked in the <see cref="F:Microsoft.EntityFrameworkCore.EntityState.Added" /> state.
                    An entity is considered to have its primary key value set if the primary key property is set
                    to anything other than the CLR default for the property type.
                </para>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.DbSet`1.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="dbSet.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="aspnetcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"> The object to compare with the current object. </param>
        <summary>
                Determines whether the specified object is equal to the current object.
            </summary>
        <returns> true if the specified object is equal to the current object; otherwise, false. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public virtual TEntity Find (params object[] keyValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance !TEntity Find(object[] keyValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.DbSet`1.Find(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Find (ParamArray keyValues As Object()) As TEntity" />
      <MemberSignature Language="F#" Value="abstract member Find : obj[] -&gt; 'Entity&#xA;override this.Find : obj[] -&gt; 'Entity" Usage="dbSet.Find keyValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TEntity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyValues" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="aspnetcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="keyValues">The values of the primary key for the entity to be found.</param>
        <summary>
                Finds an entity with the given primary key values. If an entity with the given primary key values
                is being tracked by the context, then it is returned immediately without making a request to the
                database. Otherwise, a query is made to the database for an entity with the given primary key values
                and this entity, if found, is attached to the context and returned. If no entity is found, then
                null is returned.
            </summary>
        <returns>The entity found, or null.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;TEntity&gt; FindAsync (params object[] keyValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;!TEntity&gt; FindAsync(object[] keyValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.DbSet`1.FindAsync(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindAsync (ParamArray keyValues As Object()) As Task(Of TEntity)" />
      <MemberSignature Language="F#" Value="abstract member FindAsync : obj[] -&gt; System.Threading.Tasks.Task&lt;'Entity (requires 'Entity : null)&gt;&#xA;override this.FindAsync : obj[] -&gt; System.Threading.Tasks.Task&lt;'Entity (requires 'Entity : null)&gt;" Usage="dbSet.FindAsync keyValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyValues" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="aspnetcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="keyValues">The values of the primary key for the entity to be found.</param>
        <summary>
                Finds an entity with the given primary key values. If an entity with the given primary key values
                is being tracked by the context, then it is returned immediately without making a request to the
                database. Otherwise, a query is made to the database for an entity with the given primary key values
                and this entity, if found, is attached to the context and returned. If no entity is found, then
                null is returned.
            </summary>
        <returns>The entity found, or null.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;TEntity&gt; FindAsync (object[] keyValues, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;!TEntity&gt; FindAsync(object[] keyValues, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.DbSet`1.FindAsync(System.Object[],System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member FindAsync : obj[] * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Entity (requires 'Entity : null)&gt;&#xA;override this.FindAsync : obj[] * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Entity (requires 'Entity : null)&gt;" Usage="dbSet.FindAsync (keyValues, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyValues" Type="System.Object[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="keyValues">The values of the primary key for the entity to be found.</param>
        <param name="cancellationToken">A <see cref="T:System.Threading.CancellationToken" /> to observe while waiting for the task to complete.</param>
        <summary>
                Finds an entity with the given primary key values. If an entity with the given primary key values
                is being tracked by the context, then it is returned immediately without making a request to the
                database. Otherwise, a query is made to the database for an entity with the given primary key values
                and this entity, if found, is attached to the context and returned. If no entity is found, then
                null is returned.
            </summary>
        <returns>The entity found, or null.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.DbSet`1.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dbSet.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="aspnetcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Serves as the default hash function.
            </summary>
        <returns> A hash code for the current object. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Local">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.ChangeTracking.LocalView&lt;TEntity&gt; Local { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.EntityFrameworkCore.ChangeTracking.LocalView`1&lt;!TEntity&gt; Local" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.DbSet`1.Local" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Local As LocalView(Of TEntity)" />
      <MemberSignature Language="F#" Value="member this.Local : Microsoft.EntityFrameworkCore.ChangeTracking.LocalView&lt;'Entity (requires 'Entity : null)&gt;" Usage="Microsoft.EntityFrameworkCore.DbSet&lt;'Entity (requires 'Entity : null)&gt;.Local" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.LocalView&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <para>
                    Gets an <see cref="T:Microsoft.EntityFrameworkCore.ChangeTracking.LocalView`1" /> that represents a local view of all Added, Unchanged,
                    and Modified entities in this set.
                </para>
          <para>
                    This local view will stay in sync as entities are added or removed from the context. Likewise, entities
                    added to or removed from the local view will automatically be added to or removed
                    from the context.
                </para>
          <para>
                    This property can be used for data binding by populating the set with data, for example by using the
                    <see cref="M:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.Load``1(System.Linq.IQueryable{``0})" /> extension method,
                    and then binding to the local data through this property by calling
                    <see cref="M:Microsoft.EntityFrameworkCore.ChangeTracking.LocalView`1.ToObservableCollection" /> for WPF binding, or
                    <see cref="M:Microsoft.EntityFrameworkCore.ChangeTracking.LocalView`1.ToBindingList" /> for WinForms.
                </para>
        </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Infrastructure.IInfrastructure&lt;System.IServiceProvider&gt;.Instance">
      <MemberSignature Language="C#" Value="IServiceProvider Microsoft.EntityFrameworkCore.Infrastructure.IInfrastructure&lt;System.IServiceProvider&gt;.Instance { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IServiceProvider Microsoft.EntityFrameworkCore.Infrastructure.IInfrastructure&lt;System.IServiceProvider&gt;.Instance" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.DbSet`1.Microsoft#EntityFrameworkCore#Infrastructure#IInfrastructure&lt;System#IServiceProvider&gt;#Instance" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Instance As IServiceProvider Implements IInfrastructure(Of IServiceProvider).Instance" />
      <MemberSignature Language="F#" Usage="Microsoft.EntityFrameworkCore.Infrastructure.IInfrastructure&lt;System.IServiceProvider&gt;.Instance" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Infrastructure.IInfrastructure`1.Instance</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IServiceProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <para>
                    Gets the scoped <see cref="T:System.IServiceProvider" /> being used to resolve services.
                </para>
          <para>
                    This property is intended for use by extension methods that need to make use of services
                    not directly exposed in the public API surface.
                </para>
        </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Microsoft.EntityFrameworkCore.Query.Internal.IAsyncEnumerableAccessor&lt;TEntity&gt;.AsyncEnumerable">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IAsyncEnumerable&lt;TEntity&gt; Microsoft.EntityFrameworkCore.Query.Internal.IAsyncEnumerableAccessor&lt;TEntity&gt;.AsyncEnumerable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IAsyncEnumerable`1&lt;!TEntity&gt; Microsoft.EntityFrameworkCore.Query.Internal.IAsyncEnumerableAccessor&lt;TEntity&gt;.AsyncEnumerable" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.DbSet`1.Microsoft#EntityFrameworkCore#Query#Internal#IAsyncEnumerableAccessor&lt;TEntity&gt;#AsyncEnumerable" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property AsyncEnumerable As IAsyncEnumerable(Of TEntity) Implements IAsyncEnumerableAccessor(Of TEntity).AsyncEnumerable" />
      <MemberSignature Language="F#" Usage="Microsoft.EntityFrameworkCore.Query.Internal.IAsyncEnumerableAccessor&lt;TEntity&gt;.AsyncEnumerable" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Microsoft.EntityFrameworkCore.Query.Internal.IAsyncEnumerableAccessor`1.AsyncEnumerable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IAsyncEnumerable&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                Returns an <see cref="T:System.Collections.Generic.IAsyncEnumerable`1" /> which when enumerated will asynchronously execute the query against
                the database.
            </summary>
        <value> The query results. </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.ChangeTracking.EntityEntry&lt;TEntity&gt; Remove (TEntity entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.ChangeTracking.EntityEntry`1&lt;!TEntity&gt; Remove(!TEntity entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.DbSet`1.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Remove (entity As TEntity) As EntityEntry(Of TEntity)" />
      <MemberSignature Language="F#" Value="abstract member Remove : 'Entity -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.EntityEntry&lt;'Entity (requires 'Entity : null)&gt;&#xA;override this.Remove : 'Entity -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.EntityEntry&lt;'Entity (requires 'Entity : null)&gt;" Usage="dbSet.Remove entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.EntityEntry&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
      </Parameters>
      <Docs>
        <param name="entity"> The entity to remove. </param>
        <summary>
                Begins tracking the given entity in the <see cref="F:Microsoft.EntityFrameworkCore.EntityState.Deleted" /> state such that it will
                be removed from the database when <see cref="M:Microsoft.EntityFrameworkCore.DbContext.SaveChanges" /> is called.
            </summary>
        <returns>
                The <see cref="T:Microsoft.EntityFrameworkCore.ChangeTracking.EntityEntry`1" /> for the entity. The entry provides
                access to change tracking information and operations for the entity.
            </returns>
        <remarks>
          <para>
                    If the entity is already tracked in the <see cref="F:Microsoft.EntityFrameworkCore.EntityState.Added" /> state then the context will
                    stop tracking the entity (rather than marking it as <see cref="F:Microsoft.EntityFrameworkCore.EntityState.Deleted" />) since the
                    entity was previously added to the context and does not exist in the database.
                </para>
          <para>
                    Any other reachable entities that are not already being tracked will be tracked in the same way that
                    they would be if <see cref="M:Microsoft.EntityFrameworkCore.DbSet`1.Attach(`0)" /> was called before calling this method.
                    This allows any cascading actions to be applied when <see cref="M:Microsoft.EntityFrameworkCore.DbContext.SaveChanges" /> is called.
                </para>
          <para>
                    Use <see cref="P:Microsoft.EntityFrameworkCore.ChangeTracking.EntityEntry.State" /> to set the state of only a single entity.
                </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveRange">
      <MemberSignature Language="C#" Value="public virtual void RemoveRange (System.Collections.Generic.IEnumerable&lt;TEntity&gt; entities);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveRange(class System.Collections.Generic.IEnumerable`1&lt;!TEntity&gt; entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.DbSet`1.RemoveRange(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemoveRange (entities As IEnumerable(Of TEntity))" />
      <MemberSignature Language="F#" Value="abstract member RemoveRange : seq&lt;'Entity (requires 'Entity : null)&gt; -&gt; unit&#xA;override this.RemoveRange : seq&lt;'Entity (requires 'Entity : null)&gt; -&gt; unit" Usage="dbSet.RemoveRange entities" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entities" Type="System.Collections.Generic.IEnumerable&lt;TEntity&gt;" />
      </Parameters>
      <Docs>
        <param name="entities"> The entities to remove. </param>
        <summary>
                Begins tracking the given entities in the <see cref="F:Microsoft.EntityFrameworkCore.EntityState.Deleted" /> state such that they will
                be removed from the database when <see cref="M:Microsoft.EntityFrameworkCore.DbContext.SaveChanges" /> is called.
            </summary>
        <remarks>
          <para>
                    If any of the entities are already tracked in the <see cref="F:Microsoft.EntityFrameworkCore.EntityState.Added" /> state then the context will
                    stop tracking those entities (rather than marking them as <see cref="F:Microsoft.EntityFrameworkCore.EntityState.Deleted" />) since those
                    entities were previously added to the context and do not exist in the database.
                </para>
          <para>
                    Any other reachable entities that are not already being tracked will be tracked in the same way that
                    they would be if <see cref="M:Microsoft.EntityFrameworkCore.DbSet`1.AttachRange(System.Collections.Generic.IEnumerable{`0})" /> was called before calling this method.
                    This allows any cascading actions to be applied when <see cref="M:Microsoft.EntityFrameworkCore.DbContext.SaveChanges" /> is called.
                </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveRange">
      <MemberSignature Language="C#" Value="public virtual void RemoveRange (params TEntity[] entities);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveRange(!TEntity[] entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.DbSet`1.RemoveRange(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemoveRange (ParamArray entities As TEntity())" />
      <MemberSignature Language="F#" Value="abstract member RemoveRange : 'Entity[] -&gt; unit&#xA;override this.RemoveRange : 'Entity[] -&gt; unit" Usage="dbSet.RemoveRange entities" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entities" Type="TEntity[]">
          <Attributes>
            <Attribute FrameworkAlternate="aspnetcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="entities"> The entities to remove. </param>
        <summary>
                Begins tracking the given entities in the <see cref="F:Microsoft.EntityFrameworkCore.EntityState.Deleted" /> state such that they will
                be removed from the database when <see cref="M:Microsoft.EntityFrameworkCore.DbContext.SaveChanges" /> is called.
            </summary>
        <remarks>
          <para>
                    If any of the entities are already tracked in the <see cref="F:Microsoft.EntityFrameworkCore.EntityState.Added" /> state then the context will
                    stop tracking those entities (rather than marking them as <see cref="F:Microsoft.EntityFrameworkCore.EntityState.Deleted" />) since those
                    entities were previously added to the context and do not exist in the database.
                </para>
          <para>
                    Any other reachable entities that are not already being tracked will be tracked in the same way that
                    they would be if <see cref="M:Microsoft.EntityFrameworkCore.DbSet`1.AttachRange(`0[])" /> was called before calling this method.
                    This allows any cascading actions to be applied when <see cref="M:Microsoft.EntityFrameworkCore.DbContext.SaveChanges" /> is called.
                </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;TEntity&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;TEntity&gt; IEnumerable&lt;TEntity&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!TEntity&gt; System.Collections.Generic.IEnumerable&lt;TEntity&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.DbSet`1.System#Collections#Generic#IEnumerable&lt;TEntity&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of TEntity) Implements IEnumerable(Of TEntity).GetEnumerator" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Returns an <see cref="T:System.Collections.Generic.IEnumerator`1" /> which when enumerated will execute a query against the database
                to load all entities from the database.
            </summary>
        <returns> The query results. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.DbSet`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Returns an <see cref="T:System.Collections.IEnumerator" /> which when enumerated will execute a query against the database
                to load all entities from the database.
            </summary>
        <returns> The query results. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.ContainsListCollection">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.IListSource.ContainsListCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.DbSet`1.System#ComponentModel#IListSource#ContainsListCollection" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ContainsListCollection As Boolean Implements IListSource.ContainsListCollection" />
      <MemberSignature Language="F#" Usage="System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                Gets a value indicating whether the collection is a collection of System.Collections.IList objects.
                Always returns false.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.GetList">
      <MemberSignature Language="C#" Value="System.Collections.IList IListSource.GetList ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IList System.ComponentModel.IListSource.GetList() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.DbSet`1.System#ComponentModel#IListSource#GetList" />
      <MemberSignature Language="VB.NET" Value="Function GetList () As IList Implements IListSource.GetList" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>
                    This method is called by data binding frameworks when attempting to data bind
                    directly to a <see cref="T:Microsoft.EntityFrameworkCore.DbSet`1" />.
                </para>
          <para>
                    This implementation always throws an exception as binding directly to a
                    <see cref="T:Microsoft.EntityFrameworkCore.DbSet`1" /> will result in a query being
                    sent to the database every time the data binding framework requests the contents
                    of the collection. Instead load the results into the context, for example, by using the
                    <see cref="M:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.Load``1(System.Linq.IQueryable{``0})" /> extension method,
                    and then bind to the local data through the <see cref="P:Microsoft.EntityFrameworkCore.DbSet`1.Local" /> by calling
                    <see cref="M:Microsoft.EntityFrameworkCore.ChangeTracking.LocalView`1.ToObservableCollection" /> for WPF binding, or
                    <see cref="M:Microsoft.EntityFrameworkCore.ChangeTracking.LocalView`1.ToBindingList" /> for WinForms.
                </para>
        </summary>
        <returns> Never returns, always throws an exception. </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"> Always thrown. </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Linq.IQueryable.ElementType">
      <MemberSignature Language="C#" Value="Type System.Linq.IQueryable.ElementType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type System.Linq.IQueryable.ElementType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.DbSet`1.System#Linq#IQueryable#ElementType" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ElementType As Type Implements IQueryable.ElementType" />
      <MemberSignature Language="F#" Usage="System.Linq.IQueryable.ElementType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                Gets the IQueryable element type.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Linq.IQueryable.Expression">
      <MemberSignature Language="C#" Value="System.Linq.Expressions.Expression System.Linq.IQueryable.Expression { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Linq.Expressions.Expression System.Linq.IQueryable.Expression" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.DbSet`1.System#Linq#IQueryable#Expression" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Expression As Expression Implements IQueryable.Expression" />
      <MemberSignature Language="F#" Usage="System.Linq.IQueryable.Expression" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                Gets the IQueryable LINQ Expression.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Linq.IQueryable.Provider">
      <MemberSignature Language="C#" Value="System.Linq.IQueryProvider System.Linq.IQueryable.Provider { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Linq.IQueryProvider System.Linq.IQueryable.Provider" />
      <MemberSignature Language="DocId" Value="P:Microsoft.EntityFrameworkCore.DbSet`1.System#Linq#IQueryable#Provider" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Provider As IQueryProvider Implements IQueryable.Provider" />
      <MemberSignature Language="F#" Usage="System.Linq.IQueryable.Provider" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
                Gets the IQueryable provider.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.DbSet`1.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dbSet.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="aspnetcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Returns a string that represents the current object.
            </summary>
        <returns> A string that represents the current object. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.ChangeTracking.EntityEntry&lt;TEntity&gt; Update (TEntity entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.ChangeTracking.EntityEntry`1&lt;!TEntity&gt; Update(!TEntity entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.DbSet`1.Update(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Update (entity As TEntity) As EntityEntry(Of TEntity)" />
      <MemberSignature Language="F#" Value="abstract member Update : 'Entity -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.EntityEntry&lt;'Entity (requires 'Entity : null)&gt;&#xA;override this.Update : 'Entity -&gt; Microsoft.EntityFrameworkCore.ChangeTracking.EntityEntry&lt;'Entity (requires 'Entity : null)&gt;" Usage="dbSet.Update entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.ChangeTracking.EntityEntry&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
      </Parameters>
      <Docs>
        <param name="entity"> The entity to update. </param>
        <summary>
          <para>
                    Begins tracking the given entity in the <see cref="F:Microsoft.EntityFrameworkCore.EntityState.Modified" /> state such that it will
                    be updated in the database when <see cref="M:Microsoft.EntityFrameworkCore.DbContext.SaveChanges" /> is called.
                </para>
          <para>
                    All properties of the entity will be marked as modified. To mark only some properties as modified, use
                    <see cref="M:Microsoft.EntityFrameworkCore.DbSet`1.Attach(`0)" /> to begin tracking the entity in the <see cref="F:Microsoft.EntityFrameworkCore.EntityState.Unchanged" />
                    state and then use the returned <see cref="T:Microsoft.EntityFrameworkCore.ChangeTracking.EntityEntry" /> to mark the desired properties as modified.
                </para>
          <para>
                    A recursive search of the navigation properties will be performed to find reachable entities
                    that are not already being tracked by the context. These entities will also begin to be tracked
                    by the context. If a reachable entity has its primary key value set
                    then it will be tracked in the <see cref="F:Microsoft.EntityFrameworkCore.EntityState.Modified" /> state. If the primary key
                    value is not set then it will be tracked in the <see cref="F:Microsoft.EntityFrameworkCore.EntityState.Added" /> state.
                    An entity is considered to have its primary key value set if the primary key property is set
                    to anything other than the CLR default for the property type.
                </para>
          <para>
                    Use <see cref="P:Microsoft.EntityFrameworkCore.ChangeTracking.EntityEntry.State" /> to set the state of only a single entity.
                </para>
        </summary>
        <returns>
                The <see cref="T:Microsoft.EntityFrameworkCore.ChangeTracking.EntityEntry" /> for the entity. The entry provides
                access to change tracking information and operations for the entity.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateRange">
      <MemberSignature Language="C#" Value="public virtual void UpdateRange (System.Collections.Generic.IEnumerable&lt;TEntity&gt; entities);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateRange(class System.Collections.Generic.IEnumerable`1&lt;!TEntity&gt; entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.DbSet`1.UpdateRange(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub UpdateRange (entities As IEnumerable(Of TEntity))" />
      <MemberSignature Language="F#" Value="abstract member UpdateRange : seq&lt;'Entity (requires 'Entity : null)&gt; -&gt; unit&#xA;override this.UpdateRange : seq&lt;'Entity (requires 'Entity : null)&gt; -&gt; unit" Usage="dbSet.UpdateRange entities" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entities" Type="System.Collections.Generic.IEnumerable&lt;TEntity&gt;" />
      </Parameters>
      <Docs>
        <param name="entities"> The entities to update. </param>
        <summary>
          <para>
                    Begins tracking the given entities in the <see cref="F:Microsoft.EntityFrameworkCore.EntityState.Modified" /> state such that they will
                    be updated in the database when <see cref="M:Microsoft.EntityFrameworkCore.DbContext.SaveChanges" /> is called.
                </para>
          <para>
                    All properties of each entity will be marked as modified. To mark only some properties as modified, use
                    <see cref="M:Microsoft.EntityFrameworkCore.DbSet`1.Attach(`0)" /> to begin tracking each entity in the <see cref="F:Microsoft.EntityFrameworkCore.EntityState.Unchanged" />
                    state and then use the returned <see cref="T:Microsoft.EntityFrameworkCore.ChangeTracking.EntityEntry" /> to mark the desired properties as modified.
                </para>
          <para>
                    A recursive search of the navigation properties will be performed to find reachable entities
                    that are not already being tracked by the context. These entities will also begin to be tracked
                    by the context. If a reachable entity has its primary key value set
                    then it will be tracked in the <see cref="F:Microsoft.EntityFrameworkCore.EntityState.Modified" /> state. If the primary key
                    value is not set then it will be tracked in the <see cref="F:Microsoft.EntityFrameworkCore.EntityState.Added" /> state.
                    An entity is considered to have its primary key value set if the primary key property is set
                    to anything other than the CLR default for the property type.
                </para>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateRange">
      <MemberSignature Language="C#" Value="public virtual void UpdateRange (params TEntity[] entities);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateRange(!TEntity[] entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.DbSet`1.UpdateRange(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub UpdateRange (ParamArray entities As TEntity())" />
      <MemberSignature Language="F#" Value="abstract member UpdateRange : 'Entity[] -&gt; unit&#xA;override this.UpdateRange : 'Entity[] -&gt; unit" Usage="dbSet.UpdateRange entities" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entities" Type="TEntity[]">
          <Attributes>
            <Attribute FrameworkAlternate="aspnetcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="entities"> The entities to update. </param>
        <summary>
          <para>
                    Begins tracking the given entities in the <see cref="F:Microsoft.EntityFrameworkCore.EntityState.Modified" /> state such that they will
                    be updated in the database when <see cref="M:Microsoft.EntityFrameworkCore.DbContext.SaveChanges" /> is called.
                </para>
          <para>
                    All properties of each entity will be marked as modified. To mark only some properties as modified, use
                    <see cref="M:Microsoft.EntityFrameworkCore.DbSet`1.Attach(`0)" /> to begin tracking each entity in the <see cref="F:Microsoft.EntityFrameworkCore.EntityState.Unchanged" />
                    state and then use the returned <see cref="T:Microsoft.EntityFrameworkCore.ChangeTracking.EntityEntry" /> to mark the desired properties as modified.
                </para>
          <para>
                    A recursive search of the navigation properties will be performed to find reachable entities
                    that are not already being tracked by the context. These entities will also begin to be tracked
                    by the context. If a reachable entity has its primary key value set
                    then it will be tracked in the <see cref="F:Microsoft.EntityFrameworkCore.EntityState.Modified" /> state. If the primary key
                    value is not set then it will be tracked in the <see cref="F:Microsoft.EntityFrameworkCore.EntityState.Added" /> state.
                    An entity is considered to have its primary key value set if the primary key property is set
                    to anything other than the CLR default for the property type.
                </para>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
