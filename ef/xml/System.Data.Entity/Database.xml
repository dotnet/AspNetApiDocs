<Type Name="Database" FullName="System.Data.Entity.Database">
  <TypeSignature Language="C#" Value="public class Database" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Database extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Data.Entity.Database" />
  <TypeSignature Language="VB.NET" Value="Public Class Database" />
  <TypeSignature Language="F#" Value="type Database = class" />
  <AssemblyInfo>
    <AssemblyName>EntityFramework</AssemblyName>
    <AssemblyVersion>6.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1001:TypesThatOwnDisposableFieldsShouldBeDisposable", Justification="The DbContextTransaction and EntityTransaction should never be disposed by this class")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
            An instance of this class is obtained from an <see cref="T:System.Data.Entity.DbContext" /> object and can be used
            to manage the actual database backing a DbContext or connection.
            This includes creating, deleting, and checking for the existence of a database.
            Note that deletion and checking for existence of a database can be performed using just a
            connection (i.e. without a full context) by using the static methods of this class.
            </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="BeginTransaction">
      <MemberSignature Language="C#" Value="public System.Data.Entity.DbContextTransaction BeginTransaction ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Entity.DbContextTransaction BeginTransaction() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Database.BeginTransaction" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginTransaction () As DbContextTransaction" />
      <MemberSignature Language="F#" Value="member this.BeginTransaction : unit -&gt; System.Data.Entity.DbContextTransaction" Usage="database.BeginTransaction " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Entity.DbContextTransaction</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Begins a transaction on the underlying store connection
            </summary>
        <returns>
            a <see cref="T:System.Data.Entity.DbContextTransaction" /> object wrapping access to the underlying store's transaction object
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginTransaction">
      <MemberSignature Language="C#" Value="public System.Data.Entity.DbContextTransaction BeginTransaction (System.Data.IsolationLevel isolationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Entity.DbContextTransaction BeginTransaction(valuetype System.Data.IsolationLevel isolationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Database.BeginTransaction(System.Data.IsolationLevel)" />
      <MemberSignature Language="F#" Value="member this.BeginTransaction : System.Data.IsolationLevel -&gt; System.Data.Entity.DbContextTransaction" Usage="database.BeginTransaction isolationLevel" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Entity.DbContextTransaction</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isolationLevel" Type="System.Data.IsolationLevel" />
      </Parameters>
      <Docs>
        <param name="isolationLevel">The database isolation level with which the underlying store transaction will be created</param>
        <summary>
            Begins a transaction on the underlying store connection using the specified isolation level
            </summary>
        <returns>
            a <see cref="T:System.Data.Entity.DbContextTransaction" /> object wrapping access to the underlying store's transaction object
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandTimeout">
      <MemberSignature Language="C#" Value="public Nullable&lt;int&gt; CommandTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;int32&gt; CommandTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Data.Entity.Database.CommandTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property CommandTimeout As Nullable(Of Integer)" />
      <MemberSignature Language="F#" Value="member this.CommandTimeout : Nullable&lt;int&gt; with get, set" Usage="System.Data.Entity.Database.CommandTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets or sets the timeout value, in seconds, for all context operations.
            The default value is null, where null indicates that the default value of the underlying
            provider will be used.
            </summary>
        <value>
            The timeout, in seconds, or null to use the provider default.
            </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CompatibleWithModel">
      <MemberSignature Language="C#" Value="public bool CompatibleWithModel (bool throwIfNoMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CompatibleWithModel(bool throwIfNoMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Database.CompatibleWithModel(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompatibleWithModel (throwIfNoMetadata As Boolean) As Boolean" />
      <MemberSignature Language="F#" Value="member this.CompatibleWithModel : bool -&gt; bool" Usage="database.CompatibleWithModel throwIfNoMetadata" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="throwIfNoMetadata" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="throwIfNoMetadata">
            If set to <c>true</c> then an exception will be thrown if no model metadata is found in the database. If set to <c>false</c> then this method will return <c>true</c> if metadata is not found.
            </param>
        <summary>
            Checks whether or not the database is compatible with the the current Code First model.
            </summary>
        <returns> True if the model hash in the context and the database match; false otherwise. </returns>
        <remarks>
            Model compatibility currently uses the following rules.
            If the context was created using either the Model First or Database First approach then the
            model is assumed to be compatible with the database and this method returns true.
            For Code First the model is considered compatible if the model is stored in the database
            in the Migrations history table and that model has no differences from the current model as
            determined by Migrations model differ.
            If the model is not stored in the database but an EF 4.1/4.2 model hash is found instead,
            then this is used to check for compatibility.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbConnection Connection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbConnection Connection" />
      <MemberSignature Language="DocId" Value="P:System.Data.Entity.Database.Connection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connection As DbConnection" />
      <MemberSignature Language="F#" Value="member this.Connection : System.Data.Common.DbConnection" Usage="System.Data.Entity.Database.Connection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbConnection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Returns the connection being used by this context.  This may cause the
            connection to be created if it does not already exist.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Thrown if the context has been disposed.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public void Create ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Create() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Database.Create" />
      <MemberSignature Language="VB.NET" Value="Public Sub Create ()" />
      <MemberSignature Language="F#" Value="member this.Create : unit -&gt; unit" Usage="database.Create " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Creates a new database on the database server for the model defined in the backing context.
            Note that calling this method before the database initialization strategy has run will disable
            executing that strategy.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateIfNotExists">
      <MemberSignature Language="C#" Value="public bool CreateIfNotExists ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CreateIfNotExists() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Database.CreateIfNotExists" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateIfNotExists () As Boolean" />
      <MemberSignature Language="F#" Value="member this.CreateIfNotExists : unit -&gt; bool" Usage="database.CreateIfNotExists " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Creates a new database on the database server for the model defined in the backing context, but only
            if a database with the same name does not already exist on the server.
            </summary>
        <returns> True if the database did not exist and was created; false otherwise. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentTransaction">
      <MemberSignature Language="C#" Value="public System.Data.Entity.DbContextTransaction CurrentTransaction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Entity.DbContextTransaction CurrentTransaction" />
      <MemberSignature Language="DocId" Value="P:System.Data.Entity.Database.CurrentTransaction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentTransaction As DbContextTransaction" />
      <MemberSignature Language="F#" Value="member this.CurrentTransaction : System.Data.Entity.DbContextTransaction" Usage="System.Data.Entity.Database.CurrentTransaction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Entity.DbContextTransaction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets the transaction the underlying store connection is enlisted in.  May be null.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultConnectionFactory">
      <MemberSignature Language="C#" Value="public static System.Data.Entity.Infrastructure.IDbConnectionFactory DefaultConnectionFactory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Data.Entity.Infrastructure.IDbConnectionFactory DefaultConnectionFactory" />
      <MemberSignature Language="DocId" Value="P:System.Data.Entity.Database.DefaultConnectionFactory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultConnectionFactory As IDbConnectionFactory" />
      <MemberSignature Language="F#" Value="member this.DefaultConnectionFactory : System.Data.Entity.Infrastructure.IDbConnectionFactory with get, set" Usage="System.Data.Entity.Database.DefaultConnectionFactory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The default connection factory should be set in the config file or using the DbConfiguration class. (See http://go.microsoft.com/fwlink/?LinkId=260883)")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Entity.Infrastructure.IDbConnectionFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The connection factory to use when creating a <see cref="T:System.Data.Common.DbConnection" /> from just
            a database name or a connection string.
            </summary>
        <value>To be added.</value>
        <remarks>
            This is used when just a database name or connection string is given to <see cref="T:System.Data.Entity.DbContext" /> or when
            the no database name or connection is given to DbContext in which case the name of
            the context class is passed to this factory in order to generate a DbConnection.
            By default, the <see cref="T:System.Data.Entity.Infrastructure.IDbConnectionFactory" /> instance to use is read from the application's .config
            file from the "EntityFramework DefaultConnectionFactory" entry in appSettings. If no entry is found in
            the config file then <see cref="T:System.Data.Entity.Infrastructure.SqlConnectionFactory" /> is used. Setting this property in code
            always overrides whatever value is found in the config file.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public bool Delete ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Delete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Database.Delete" />
      <MemberSignature Language="VB.NET" Value="Public Function Delete () As Boolean" />
      <MemberSignature Language="F#" Value="member this.Delete : unit -&gt; bool" Usage="database.Delete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Deletes the database on the database server if it exists, otherwise does nothing.
            Calling this method from outside of an initializer will mark the database as having
            not been initialized. This means that if an attempt is made to use the database again
            after it has been deleted, then any initializer set will run again and, usually, will
            try to create the database again automatically.
            </summary>
        <returns> True if the database did exist and was deleted; false otherwise. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static bool Delete (System.Data.Common.DbConnection existingConnection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Delete(class System.Data.Common.DbConnection existingConnection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Database.Delete(System.Data.Common.DbConnection)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Delete (existingConnection As DbConnection) As Boolean" />
      <MemberSignature Language="F#" Value="static member Delete : System.Data.Common.DbConnection -&gt; bool" Usage="System.Data.Entity.Database.Delete existingConnection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="existingConnection" Type="System.Data.Common.DbConnection" />
      </Parameters>
      <Docs>
        <param name="existingConnection"> An existing connection to the database. </param>
        <summary>
            Deletes the database on the database server if it exists, otherwise does nothing.
            </summary>
        <returns> True if the database did exist and was deleted; false otherwise. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static bool Delete (string nameOrConnectionString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Delete(string nameOrConnectionString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Database.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Delete (nameOrConnectionString As String) As Boolean" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; bool" Usage="System.Data.Entity.Database.Delete nameOrConnectionString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Reliability", "CA2000:Dispose objects before losing scope")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nameOrConnectionString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="nameOrConnectionString"> The database name or a connection string to the database. </param>
        <summary>
            Deletes the database on the database server if it exists, otherwise does nothing.
            The connection to the database is created using the given database name or connection string
            in the same way as is described in the documentation for the <see cref="T:System.Data.Entity.DbContext" /> class.
            </summary>
        <returns> True if the database did exist and was deleted; false otherwise. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Database.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="database.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="ExecuteSqlCommand">
      <MemberSignature Language="C#" Value="public int ExecuteSqlCommand (string sql, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteSqlCommand(string sql, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Database.ExecuteSqlCommand(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteSqlCommand (sql As String, ParamArray parameters As Object()) As Integer" />
      <MemberSignature Language="F#" Value="member this.ExecuteSqlCommand : string * obj[] -&gt; int" Usage="database.ExecuteSqlCommand (sql, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sql" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="sql"> The command string. </param>
        <param name="parameters"> The parameters to apply to the command string. </param>
        <summary>
             Executes the given DDL/DML command against the database.
            
             As with any API that accepts SQL it is important to parameterize any user input to protect against a SQL injection attack. You can include parameter place holders in the SQL query string and then supply parameter values as additional arguments. Any parameter values you supply will automatically be converted to a DbParameter.
             context.Database.ExecuteSqlCommand("UPDATE dbo.Posts SET Rating = 5 WHERE Author = @p0", userSuppliedAuthor);
             Alternatively, you can also construct a DbParameter and supply it to SqlQuery. This allows you to use named parameters in the SQL query string.
             context.Database.ExecuteSqlCommand("UPDATE dbo.Posts SET Rating = 5 WHERE Author = @author", new SqlParameter("@author", userSuppliedAuthor));
             </summary>
        <returns> The result returned by the database after executing the command. </returns>
        <remarks>
             If there isn't an existing local or ambient transaction a new transaction will be used
             to execute the command.
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteSqlCommand">
      <MemberSignature Language="C#" Value="public int ExecuteSqlCommand (System.Data.Entity.TransactionalBehavior transactionalBehavior, string sql, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteSqlCommand(valuetype System.Data.Entity.TransactionalBehavior transactionalBehavior, string sql, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Database.ExecuteSqlCommand(System.Data.Entity.TransactionalBehavior,System.String,System.Object[])" />
      <MemberSignature Language="F#" Value="member this.ExecuteSqlCommand : System.Data.Entity.TransactionalBehavior * string * obj[] -&gt; int" Usage="database.ExecuteSqlCommand (transactionalBehavior, sql, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionalBehavior" Type="System.Data.Entity.TransactionalBehavior" />
        <Parameter Name="sql" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="transactionalBehavior"> Controls the creation of a transaction for this command. </param>
        <param name="sql"> The command string. </param>
        <param name="parameters"> The parameters to apply to the command string. </param>
        <summary>
             Executes the given DDL/DML command against the database.
            
             As with any API that accepts SQL it is important to parameterize any user input to protect against a SQL injection attack. You can include parameter place holders in the SQL query string and then supply parameter values as additional arguments. Any parameter values you supply will automatically be converted to a DbParameter.
             context.Database.ExecuteSqlCommand("UPDATE dbo.Posts SET Rating = 5 WHERE Author = @p0", userSuppliedAuthor);
             Alternatively, you can also construct a DbParameter and supply it to SqlQuery. This allows you to use named parameters in the SQL query string.
             context.Database.ExecuteSqlCommand("UPDATE dbo.Posts SET Rating = 5 WHERE Author = @author", new SqlParameter("@author", userSuppliedAuthor));
             </summary>
        <returns> The result returned by the database after executing the command. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteSqlCommandAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;int&gt; ExecuteSqlCommandAsync (string sql, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;int32&gt; ExecuteSqlCommandAsync(string sql, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Database.ExecuteSqlCommandAsync(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteSqlCommandAsync (sql As String, ParamArray parameters As Object()) As Task(Of Integer)" />
      <MemberSignature Language="F#" Value="member this.ExecuteSqlCommandAsync : string * obj[] -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="database.ExecuteSqlCommandAsync (sql, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sql" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="sql"> The command string. </param>
        <param name="parameters"> The parameters to apply to the command string. </param>
        <summary>
             Asynchronously executes the given DDL/DML command against the database.
            
             As with any API that accepts SQL it is important to parameterize any user input to protect against a SQL injection attack. You can include parameter place holders in the SQL query string and then supply parameter values as additional arguments. Any parameter values you supply will automatically be converted to a DbParameter.
             context.Database.ExecuteSqlCommandAsync("UPDATE dbo.Posts SET Rating = 5 WHERE Author = @p0", userSuppliedAuthor);
             Alternatively, you can also construct a DbParameter and supply it to SqlQuery. This allows you to use named parameters in the SQL query string.
             context.Database.ExecuteSqlCommandAsync("UPDATE dbo.Posts SET Rating = 5 WHERE Author = @author", new SqlParameter("@author", userSuppliedAuthor));
             </summary>
        <returns>
             A task that represents the asynchronous operation.
             The task result contains the result returned by the database after executing the command.
             </returns>
        <remarks>
             Multiple active operations on the same context instance are not supported.  Use 'await' to ensure
             that any asynchronous operations have completed before calling another method on this context.
             
             If there isn't an existing local transaction a new transaction will be used
             to execute the command.
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteSqlCommandAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;int&gt; ExecuteSqlCommandAsync (System.Data.Entity.TransactionalBehavior transactionalBehavior, string sql, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;int32&gt; ExecuteSqlCommandAsync(valuetype System.Data.Entity.TransactionalBehavior transactionalBehavior, string sql, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Database.ExecuteSqlCommandAsync(System.Data.Entity.TransactionalBehavior,System.String,System.Object[])" />
      <MemberSignature Language="F#" Value="member this.ExecuteSqlCommandAsync : System.Data.Entity.TransactionalBehavior * string * obj[] -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="database.ExecuteSqlCommandAsync (transactionalBehavior, sql, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionalBehavior" Type="System.Data.Entity.TransactionalBehavior" />
        <Parameter Name="sql" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="transactionalBehavior"> Controls the creation of a transaction for this command. </param>
        <param name="sql"> The command string. </param>
        <param name="parameters"> The parameters to apply to the command string. </param>
        <summary>
             Asynchronously executes the given DDL/DML command against the database.
            
             As with any API that accepts SQL it is important to parameterize any user input to protect against a SQL injection attack. You can include parameter place holders in the SQL query string and then supply parameter values as additional arguments. Any parameter values you supply will automatically be converted to a DbParameter.
             context.Database.ExecuteSqlCommandAsync("UPDATE dbo.Posts SET Rating = 5 WHERE Author = @p0", userSuppliedAuthor);
             Alternatively, you can also construct a DbParameter and supply it to SqlQuery. This allows you to use named parameters in the SQL query string.
             context.Database.ExecuteSqlCommandAsync("UPDATE dbo.Posts SET Rating = 5 WHERE Author = @author", new SqlParameter("@author", userSuppliedAuthor));
             </summary>
        <returns>
             A task that represents the asynchronous operation.
             The task result contains the result returned by the database after executing the command.
             </returns>
        <remarks>
             Multiple active operations on the same context instance are not supported.  Use 'await' to ensure
             that any asynchronous operations have completed before calling another method on this context.
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteSqlCommandAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;int&gt; ExecuteSqlCommandAsync (string sql, System.Threading.CancellationToken cancellationToken, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;int32&gt; ExecuteSqlCommandAsync(string sql, valuetype System.Threading.CancellationToken cancellationToken, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Database.ExecuteSqlCommandAsync(System.String,System.Threading.CancellationToken,System.Object[])" />
      <MemberSignature Language="F#" Value="member this.ExecuteSqlCommandAsync : string * System.Threading.CancellationToken * obj[] -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="database.ExecuteSqlCommandAsync (sql, cancellationToken, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sql" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="sql"> The command string. </param>
        <param name="cancellationToken">
             A <see cref="T:System.Threading.CancellationToken" /> to observe while waiting for the task to complete.
             </param>
        <param name="parameters"> The parameters to apply to the command string. </param>
        <summary>
             Asynchronously executes the given DDL/DML command against the database.
            
             As with any API that accepts SQL it is important to parameterize any user input to protect against a SQL injection attack. You can include parameter place holders in the SQL query string and then supply parameter values as additional arguments. Any parameter values you supply will automatically be converted to a DbParameter.
             context.Database.ExecuteSqlCommandAsync("UPDATE dbo.Posts SET Rating = 5 WHERE Author = @p0", userSuppliedAuthor);
             Alternatively, you can also construct a DbParameter and supply it to SqlQuery. This allows you to use named parameters in the SQL query string.
             context.Database.ExecuteSqlCommandAsync("UPDATE dbo.Posts SET Rating = 5 WHERE Author = @author", new SqlParameter("@author", userSuppliedAuthor));
             </summary>
        <returns>
             A task that represents the asynchronous operation.
             The task result contains the result returned by the database after executing the command.
             </returns>
        <remarks>
             Multiple active operations on the same context instance are not supported.  Use 'await' to ensure
             that any asynchronous operations have completed before calling another method on this context.
             
             If there isn't an existing local transaction a new transaction will be used
             to execute the command.
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteSqlCommandAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;int&gt; ExecuteSqlCommandAsync (System.Data.Entity.TransactionalBehavior transactionalBehavior, string sql, System.Threading.CancellationToken cancellationToken, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;int32&gt; ExecuteSqlCommandAsync(valuetype System.Data.Entity.TransactionalBehavior transactionalBehavior, string sql, valuetype System.Threading.CancellationToken cancellationToken, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Database.ExecuteSqlCommandAsync(System.Data.Entity.TransactionalBehavior,System.String,System.Threading.CancellationToken,System.Object[])" />
      <MemberSignature Language="F#" Value="member this.ExecuteSqlCommandAsync : System.Data.Entity.TransactionalBehavior * string * System.Threading.CancellationToken * obj[] -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="database.ExecuteSqlCommandAsync (transactionalBehavior, sql, cancellationToken, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionalBehavior" Type="System.Data.Entity.TransactionalBehavior" />
        <Parameter Name="sql" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="transactionalBehavior"> Controls the creation of a transaction for this command. </param>
        <param name="sql"> The command string. </param>
        <param name="cancellationToken">
             A <see cref="T:System.Threading.CancellationToken" /> to observe while waiting for the task to complete.
             </param>
        <param name="parameters"> The parameters to apply to the command string. </param>
        <summary>
             Asynchronously executes the given DDL/DML command against the database.
            
             As with any API that accepts SQL it is important to parameterize any user input to protect against a SQL injection attack. You can include parameter place holders in the SQL query string and then supply parameter values as additional arguments. Any parameter values you supply will automatically be converted to a DbParameter.
             context.Database.ExecuteSqlCommandAsync("UPDATE dbo.Posts SET Rating = 5 WHERE Author = @p0", userSuppliedAuthor);
             Alternatively, you can also construct a DbParameter and supply it to SqlQuery. This allows you to use named parameters in the SQL query string.
             context.Database.ExecuteSqlCommandAsync("UPDATE dbo.Posts SET Rating = 5 WHERE Author = @author", new SqlParameter("@author", userSuppliedAuthor));
             </summary>
        <returns>
             A task that represents the asynchronous operation.
             The task result contains the result returned by the database after executing the command.
             </returns>
        <remarks>
             Multiple active operations on the same context instance are not supported.  Use 'await' to ensure
             that any asynchronous operations have completed before calling another method on this context.
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public bool Exists ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Exists() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Database.Exists" />
      <MemberSignature Language="VB.NET" Value="Public Function Exists () As Boolean" />
      <MemberSignature Language="F#" Value="member this.Exists : unit -&gt; bool" Usage="database.Exists " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Checks whether or not the database exists on the server.
            </summary>
        <returns> True if the database exists; false otherwise. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (System.Data.Common.DbConnection existingConnection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(class System.Data.Common.DbConnection existingConnection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Database.Exists(System.Data.Common.DbConnection)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (existingConnection As DbConnection) As Boolean" />
      <MemberSignature Language="F#" Value="static member Exists : System.Data.Common.DbConnection -&gt; bool" Usage="System.Data.Entity.Database.Exists existingConnection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="existingConnection" Type="System.Data.Common.DbConnection" />
      </Parameters>
      <Docs>
        <param name="existingConnection"> An existing connection to the database. </param>
        <summary>
            Checks whether or not the database exists on the server.
            </summary>
        <returns> True if the database exists; false otherwise. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string nameOrConnectionString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string nameOrConnectionString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Database.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (nameOrConnectionString As String) As Boolean" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.Data.Entity.Database.Exists nameOrConnectionString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Reliability", "CA2000:Dispose objects before losing scope")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nameOrConnectionString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="nameOrConnectionString"> The database name or a connection string to the database. </param>
        <summary>
            Checks whether or not the database exists on the server.
            The connection to the database is created using the given database name or connection string
            in the same way as is described in the documentation for the <see cref="T:System.Data.Entity.DbContext" /> class.
            </summary>
        <returns> True if the database exists; false otherwise. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Database.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="database.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Database.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="database.GetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Gets the <see cref="T:System.Type" /> of the current instance.
            </summary>
        <returns>The exact runtime type of the current instance.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public void Initialize (bool force);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Initialize(bool force) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Database.Initialize(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Initialize (force As Boolean)" />
      <MemberSignature Language="F#" Value="member this.Initialize : bool -&gt; unit" Usage="database.Initialize force" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="force" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="force">
            If set to <c>true</c> the initializer is run even if it has already been run.
            </param>
        <summary>
            Runs the the registered <see cref="T:System.Data.Entity.IDatabaseInitializer`1" /> on this context.
            If "force" is set to true, then the initializer is run regardless of whether or not it
            has been run before.  This can be useful if a database is deleted while an app is running
            and needs to be reinitialized.
            If "force" is set to false, then the initializer is only run if it has not already been
            run for this context, model, and connection in this app domain. This method is typically
            used when it is necessary to ensure that the database has been created and seeded
            before starting some operation where doing so lazily will cause issues, such as when the
            operation is part of a transaction.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public Action&lt;string&gt; Log { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Action`1&lt;string&gt; Log" />
      <MemberSignature Language="DocId" Value="P:System.Data.Entity.Database.Log" />
      <MemberSignature Language="VB.NET" Value="Public Property Log As Action(Of String)" />
      <MemberSignature Language="F#" Value="member this.Log : Action&lt;string&gt; with get, set" Usage="System.Data.Entity.Database.Log" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Action&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Set this property to log the SQL generated by the <see cref="T:System.Data.Entity.DbContext" /> to the given
            delegate. For example, to log to the console, set this property to <see cref="M:System.Console.Write(System.String)" />.
            </summary>
        <value>To be added.</value>
        <remarks>
            The format of the log text can be changed by creating a new formatter that derives from
            <see cref="T:System.Data.Entity.Infrastructure.Interception.DatabaseLogFormatter" /> and setting it with <see cref="M:System.Data.Entity.DbConfiguration.SetDatabaseLogFormatter(System.Func{System.Data.Entity.DbContext,System.Action{System.String},System.Data.Entity.Infrastructure.Interception.DatabaseLogFormatter})" />.
            For more low-level control over logging/interception see <see cref="T:System.Data.Entity.Infrastructure.Interception.IDbCommandInterceptor" /> and
            <see cref="T:System.Data.Entity.Infrastructure.Interception.DbInterception" />.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetInitializer&lt;TContext&gt;">
      <MemberSignature Language="C#" Value="public static void SetInitializer&lt;TContext&gt; (System.Data.Entity.IDatabaseInitializer&lt;TContext&gt; strategy) where TContext : System.Data.Entity.DbContext;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetInitializer&lt;(class System.Data.Entity.DbContext) TContext&gt;(class System.Data.Entity.IDatabaseInitializer`1&lt;!!TContext&gt; strategy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Database.SetInitializer``1(System.Data.Entity.IDatabaseInitializer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetInitializer(Of TContext As DbContext) (strategy As IDatabaseInitializer(Of TContext))" />
      <MemberSignature Language="F#" Value="static member SetInitializer : System.Data.Entity.IDatabaseInitializer&lt;'Context (requires 'Context :&gt; System.Data.Entity.DbContext)&gt; -&gt; unit (requires 'Context :&gt; System.Data.Entity.DbContext)" Usage="System.Data.Entity.Database.SetInitializer strategy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TContext">
          <Constraints>
            <BaseTypeName>System.Data.Entity.DbContext</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="strategy" Type="System.Data.Entity.IDatabaseInitializer&lt;TContext&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TContext"> The type of the context. </typeparam>
        <param name="strategy"> The initializer to use, or null to disable initialization for the given context type. </param>
        <summary>
            Sets the database initializer to use for the given context type.  The database initializer is called when a
            the given <see cref="T:System.Data.Entity.DbContext" /> type is used to access a database for the first time.
            The default strategy for Code First contexts is an instance of <see cref="T:System.Data.Entity.CreateDatabaseIfNotExists`1" />.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SqlQuery">
      <MemberSignature Language="C#" Value="public System.Data.Entity.Infrastructure.DbRawSqlQuery SqlQuery (Type elementType, string sql, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Entity.Infrastructure.DbRawSqlQuery SqlQuery(class System.Type elementType, string sql, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Database.SqlQuery(System.Type,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function SqlQuery (elementType As Type, sql As String, ParamArray parameters As Object()) As DbRawSqlQuery" />
      <MemberSignature Language="F#" Value="member this.SqlQuery : Type * string * obj[] -&gt; System.Data.Entity.Infrastructure.DbRawSqlQuery" Usage="database.SqlQuery (elementType, sql, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Entity.Infrastructure.DbRawSqlQuery</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="sql" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType"> The type of object returned by the query. </param>
        <param name="sql"> The SQL query string. </param>
        <param name="parameters"> 
             The parameters to apply to the SQL query string. If output parameters are used, their values 
             will not be available until the results have been read completely. This is due to the underlying 
             behavior of DbDataReader, see http://go.microsoft.com/fwlink/?LinkID=398589 for more details.
             </param>
        <summary>
             Creates a raw SQL query that will return elements of the given type.
             The type can be any type that has properties that match the names of the columns returned
             from the query, or can be a simple primitive type.  The type does not have to be an
             entity type. The results of this query are never tracked by the context even if the
             type of object returned is an entity type.  Use the <see cref="M:System.Data.Entity.DbSet.SqlQuery(System.String,System.Object[])" />
             method to return entities that are tracked by the context.
            
             As with any API that accepts SQL it is important to parameterize any user input to protect against a SQL injection attack. You can include parameter place holders in the SQL query string and then supply parameter values as additional arguments. Any parameter values you supply will automatically be converted to a DbParameter.
             context.Database.SqlQuery(typeof(Post), "SELECT * FROM dbo.Posts WHERE Author = @p0", userSuppliedAuthor);
             Alternatively, you can also construct a DbParameter and supply it to SqlQuery. This allows you to use named parameters in the SQL query string.
             context.Database.SqlQuery(typeof(Post), "SELECT * FROM dbo.Posts WHERE Author = @author", new SqlParameter("@author", userSuppliedAuthor));
             </summary>
        <returns>
             A <see cref="T:System.Data.Entity.Infrastructure.DbRawSqlQuery" /> object that will execute the query when it is enumerated.
             </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SqlQuery&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Entity.Infrastructure.DbRawSqlQuery&lt;TElement&gt; SqlQuery&lt;TElement&gt; (string sql, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Entity.Infrastructure.DbRawSqlQuery`1&lt;!!TElement&gt; SqlQuery&lt;TElement&gt;(string sql, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Database.SqlQuery``1(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function SqlQuery(Of TElement) (sql As String, ParamArray parameters As Object()) As DbRawSqlQuery(Of TElement)" />
      <MemberSignature Language="F#" Value="member this.SqlQuery : string * obj[] -&gt; System.Data.Entity.Infrastructure.DbRawSqlQuery&lt;'Element&gt;" Usage="database.SqlQuery (sql, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Entity.Infrastructure.DbRawSqlQuery&lt;TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="sql" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TElement"> The type of object returned by the query. </typeparam>
        <param name="sql"> The SQL query string. </param>
        <param name="parameters"> 
             The parameters to apply to the SQL query string. If output parameters are used, their values will 
             not be available until the results have been read completely. This is due to the underlying behavior 
             of DbDataReader, see http://go.microsoft.com/fwlink/?LinkID=398589 for more details.
             </param>
        <summary>
             Creates a raw SQL query that will return elements of the given generic type.
             The type can be any type that has properties that match the names of the columns returned
             from the query, or can be a simple primitive type.  The type does not have to be an
             entity type. The results of this query are never tracked by the context even if the
             type of object returned is an entity type.  Use the <see cref="M:System.Data.Entity.DbSet`1.SqlQuery(System.String,System.Object[])" />
             method to return entities that are tracked by the context.
            
             As with any API that accepts SQL it is important to parameterize any user input to protect against a SQL injection attack. You can include parameter place holders in the SQL query string and then supply parameter values as additional arguments. Any parameter values you supply will automatically be converted to a DbParameter.
             context.Database.SqlQuery&lt;Post&gt;("SELECT * FROM dbo.Posts WHERE Author = @p0", userSuppliedAuthor);
             Alternatively, you can also construct a DbParameter and supply it to SqlQuery. This allows you to use named parameters in the SQL query string.
             context.Database.SqlQuery&lt;Post&gt;("SELECT * FROM dbo.Posts WHERE Author = @author", new SqlParameter("@author", userSuppliedAuthor));
             </summary>
        <returns>
             A <see cref="T:System.Data.Entity.Infrastructure.DbRawSqlQuery`1" /> object that will execute the query when it is enumerated.
             </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Database.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="database.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="UseTransaction">
      <MemberSignature Language="C#" Value="public void UseTransaction (System.Data.Common.DbTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UseTransaction(class System.Data.Common.DbTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Database.UseTransaction(System.Data.Common.DbTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UseTransaction (transaction As DbTransaction)" />
      <MemberSignature Language="F#" Value="member this.UseTransaction : System.Data.Common.DbTransaction -&gt; unit" Usage="database.UseTransaction transaction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Data.Common.DbTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction">the external transaction</param>
        <summary>
            Enables the user to pass in a database transaction created outside of the <see cref="T:System.Data.Entity.Database" /> object
            if you want the Entity Framework to execute commands within that external transaction.
            Alternatively, pass in null to clear the framework's knowledge of that transaction.
            </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Thrown if the connection associated with the transaction does not match the Entity Framework's connection</exception>
      </Docs>
    </Member>
  </Members>
</Type>