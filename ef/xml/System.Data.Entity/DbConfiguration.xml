<Type Name="DbConfiguration" FullName="System.Data.Entity.DbConfiguration">
  <TypeSignature Language="C#" Value="public class DbConfiguration" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DbConfiguration extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Data.Entity.DbConfiguration" />
  <TypeSignature Language="VB.NET" Value="Public Class DbConfiguration" />
  <TypeSignature Language="F#" Value="type DbConfiguration = class" />
  <AssemblyInfo>
    <AssemblyName>EntityFramework</AssemblyName>
    <AssemblyVersion>6.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
            A class derived from this class can be placed in the same assembly as a class derived from
            <see cref="T:System.Data.Entity.DbContext" /> to define Entity Framework configuration for an application.
            Configuration is set by calling protected methods and setting protected properties of this
            class in the constructor of your derived type.
            The type to use can also be registered in the config file of the application.
            See http://go.microsoft.com/fwlink/?LinkId=260883 for more information about Entity Framework configuration.
            </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected internal DbConfiguration ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.DbConfiguration.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub New ()" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
            Any class derived from <see cref="T:System.Data.Entity.DbConfiguration" /> must have a public parameterless constructor
            and that constructor should call this constructor.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddDefaultResolver">
      <MemberSignature Language="C#" Value="protected internal void AddDefaultResolver (System.Data.Entity.Infrastructure.DependencyResolution.IDbDependencyResolver resolver);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddDefaultResolver(class System.Data.Entity.Infrastructure.DependencyResolution.IDbDependencyResolver resolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.DbConfiguration.AddDefaultResolver(System.Data.Entity.Infrastructure.DependencyResolution.IDbDependencyResolver)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddDefaultResolver (resolver As IDbDependencyResolver)" />
      <MemberSignature Language="F#" Value="member this.AddDefaultResolver : System.Data.Entity.Infrastructure.DependencyResolution.IDbDependencyResolver -&gt; unit" Usage="dbConfiguration.AddDefaultResolver resolver" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resolver" Type="System.Data.Entity.Infrastructure.DependencyResolution.IDbDependencyResolver" />
      </Parameters>
      <Docs>
        <param name="resolver"> The resolver to add. </param>
        <summary>
            Call this method from the constructor of a class derived from <see cref="T:System.Data.Entity.DbConfiguration" /> to
            add a <see cref="T:System.Data.Entity.Infrastructure.DependencyResolution.IDbDependencyResolver" /> instance to the Chain of Responsibility of resolvers that
            are used to resolve dependencies needed by the Entity Framework. Unlike the AddDependencyResolver
            method, this method puts the resolver at the bottom of the Chain of Responsibility such that it will only
            be used to resolve a dependency that could not be resolved by any of the other resolvers.
            </summary>
        <remarks>
            A <see cref="T:System.Data.Entity.Core.Common.DbProviderServices" /> implementation is automatically registered as a default resolver
            when it is added with a call to <see cref="M:System.Data.Entity.DbConfiguration.SetProviderServices(System.String,System.Data.Entity.Core.Common.DbProviderServices)" />. This allows EF providers to act as
            resolvers for other services that may need to be overridden by the provider.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddDependencyResolver">
      <MemberSignature Language="C#" Value="protected internal void AddDependencyResolver (System.Data.Entity.Infrastructure.DependencyResolution.IDbDependencyResolver resolver);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddDependencyResolver(class System.Data.Entity.Infrastructure.DependencyResolution.IDbDependencyResolver resolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.DbConfiguration.AddDependencyResolver(System.Data.Entity.Infrastructure.DependencyResolution.IDbDependencyResolver)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddDependencyResolver (resolver As IDbDependencyResolver)" />
      <MemberSignature Language="F#" Value="member this.AddDependencyResolver : System.Data.Entity.Infrastructure.DependencyResolution.IDbDependencyResolver -&gt; unit" Usage="dbConfiguration.AddDependencyResolver resolver" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resolver" Type="System.Data.Entity.Infrastructure.DependencyResolution.IDbDependencyResolver" />
      </Parameters>
      <Docs>
        <param name="resolver"> The resolver to add. </param>
        <summary>
            Call this method from the constructor of a class derived from <see cref="T:System.Data.Entity.DbConfiguration" /> to
            add a <see cref="T:System.Data.Entity.Infrastructure.DependencyResolution.IDbDependencyResolver" /> instance to the Chain of Responsibility of resolvers that
            are used to resolve dependencies needed by the Entity Framework.
            </summary>
        <remarks>
            Resolvers are asked to resolve dependencies in reverse order from which they are added. This means
            that a resolver can be added to override resolution of a dependency that would already have been
            resolved in a different way.
            The exceptions to this is that any dependency registered in the application's config file
            will always be used in preference to using a dependency resolver added here.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddInterceptor">
      <MemberSignature Language="C#" Value="protected internal void AddInterceptor (System.Data.Entity.Infrastructure.Interception.IDbInterceptor interceptor);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddInterceptor(class System.Data.Entity.Infrastructure.Interception.IDbInterceptor interceptor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.DbConfiguration.AddInterceptor(System.Data.Entity.Infrastructure.Interception.IDbInterceptor)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddInterceptor (interceptor As IDbInterceptor)" />
      <MemberSignature Language="F#" Value="member this.AddInterceptor : System.Data.Entity.Infrastructure.Interception.IDbInterceptor -&gt; unit" Usage="dbConfiguration.AddInterceptor interceptor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interceptor" Type="System.Data.Entity.Infrastructure.Interception.IDbInterceptor" />
      </Parameters>
      <Docs>
        <param name="interceptor">The interceptor to register.</param>
        <summary>
            Call this method from the constructor of a class derived from <see cref="T:System.Data.Entity.DbConfiguration" /> to
            register an <see cref="T:System.Data.Entity.Infrastructure.Interception.IDbInterceptor" /> at application startup. Note that interceptors can also
            be added and removed at any time using <see cref="T:System.Data.Entity.Infrastructure.Interception.DbInterception" />.
            </summary>
        <remarks>
            This method is provided as a convenient and discoverable way to add configuration to the Entity Framework.
            Internally it works in the same way as using AddDependencyResolver to add an appropriate resolver for
            <see cref="T:System.Data.Entity.Infrastructure.Interception.IDbInterceptor" />. This means that, if desired, the same functionality can be achieved using
            a custom resolver or a resolver backed by an Inversion-of-Control container.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="DependencyResolver">
      <MemberSignature Language="C#" Value="public static System.Data.Entity.Infrastructure.DependencyResolution.IDbDependencyResolver DependencyResolver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Data.Entity.Infrastructure.DependencyResolution.IDbDependencyResolver DependencyResolver" />
      <MemberSignature Language="DocId" Value="P:System.Data.Entity.DbConfiguration.DependencyResolver" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DependencyResolver As IDbDependencyResolver" />
      <MemberSignature Language="F#" Value="member this.DependencyResolver : System.Data.Entity.Infrastructure.DependencyResolution.IDbDependencyResolver" Usage="System.Data.Entity.DbConfiguration.DependencyResolver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Entity.Infrastructure.DependencyResolution.IDbDependencyResolver</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets the <see cref="T:System.Data.Entity.Infrastructure.DependencyResolution.IDbDependencyResolver" /> that is being used to resolve service
            dependencies in the Entity Framework.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.DbConfiguration.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="dbConfiguration.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.DbConfiguration.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dbConfiguration.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.DbConfiguration.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="dbConfiguration.GetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Gets the <see cref="T:System.Type" /> of the current instance.
            </summary>
        <returns>The exact runtime type of the current instance.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadConfiguration">
      <MemberSignature Language="C#" Value="public static void LoadConfiguration (System.Reflection.Assembly assemblyHint);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LoadConfiguration(class System.Reflection.Assembly assemblyHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.DbConfiguration.LoadConfiguration(System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LoadConfiguration (assemblyHint As Assembly)" />
      <MemberSignature Language="F#" Value="static member LoadConfiguration : System.Reflection.Assembly -&gt; unit" Usage="System.Data.Entity.DbConfiguration.LoadConfiguration assemblyHint" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyHint" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="assemblyHint">An <see cref="T:System.Reflection.Assembly" /> to use for configuration discovery.</param>
        <summary>
            Attempts to discover and load the <see cref="T:System.Data.Entity.DbConfiguration" /> from the given assembly.
            This method is intended to be used by tooling to ensure that the correct configuration is loaded into
            the app domain. Tooling should use this method before accessing the <see cref="P:System.Data.Entity.DbConfiguration.DependencyResolver" />
            property. If the tooling knows the <see cref="T:System.Data.Entity.DbContext" /> type being used, then the
            <see cref="M:System.Data.Entity.DbConfiguration.LoadConfiguration(System.Type)" /> method should be used since it gives a greater chance that
            the correct configuration will be found.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadConfiguration">
      <MemberSignature Language="C#" Value="public static void LoadConfiguration (Type contextType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LoadConfiguration(class System.Type contextType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.DbConfiguration.LoadConfiguration(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LoadConfiguration (contextType As Type)" />
      <MemberSignature Language="F#" Value="static member LoadConfiguration : Type -&gt; unit" Usage="System.Data.Entity.DbConfiguration.LoadConfiguration contextType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="contextType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="contextType">A <see cref="T:System.Data.Entity.DbContext" /> type to use for configuration discovery.</param>
        <summary>
            Attempts to discover and load the <see cref="T:System.Data.Entity.DbConfiguration" /> associated with the given
            <see cref="T:System.Data.Entity.DbContext" /> type. This method is intended to be used by tooling to ensure that
            the correct configuration is loaded into the app domain. Tooling should use this method
            before accessing the <see cref="P:System.Data.Entity.DbConfiguration.DependencyResolver" /> property.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Data.Entity.Infrastructure.DependencyResolution.DbConfigurationLoadedEventArgs&gt; Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Data.Entity.Infrastructure.DependencyResolution.DbConfigurationLoadedEventArgs&gt; Loaded" />
      <MemberSignature Language="DocId" Value="E:System.Data.Entity.DbConfiguration.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event Loaded As EventHandler(Of DbConfigurationLoadedEventArgs) " />
      <MemberSignature Language="F#" Value="member this.Loaded : EventHandler&lt;System.Data.Entity.Infrastructure.DependencyResolution.DbConfigurationLoadedEventArgs&gt; " Usage="member this.Loaded : System.EventHandler&lt;System.Data.Entity.Infrastructure.DependencyResolution.DbConfigurationLoadedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Data.Entity.Infrastructure.DependencyResolution.DbConfigurationLoadedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Occurs during EF initialization after the DbConfiguration has been constructed but just before
            it is locked ready for use. Use this event to inspect and/or override services that have been
            registered before the configuration is locked. Note that this event should be used carefully
            since it may prevent tooling from discovering the same configuration that is used at runtime.
            </summary>
        <remarks>
            Handlers can only be added before EF starts to use the configuration and so handlers should
            generally be added as part of application initialization. Do not access the DbConfiguration
            static methods inside the handler; instead use the the members of <see cref="T:System.Data.Entity.Infrastructure.DependencyResolution.DbConfigurationLoadedEventArgs" />
            to get current services and/or add overrides.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected object MemberwiseClone ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object MemberwiseClone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.DbConfiguration.MemberwiseClone" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone () As Object" />
      <MemberSignature Language="F#" Value="override this.MemberwiseClone : unit -&gt; obj" Usage="dbConfiguration.MemberwiseClone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Creates a shallow copy of the current <see cref="T:System.Object" />.
            </summary>
        <returns>A shallow copy of the current <see cref="T:System.Object" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetConfiguration">
      <MemberSignature Language="C#" Value="public static void SetConfiguration (System.Data.Entity.DbConfiguration configuration);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetConfiguration(class System.Data.Entity.DbConfiguration configuration) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.DbConfiguration.SetConfiguration(System.Data.Entity.DbConfiguration)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetConfiguration (configuration As DbConfiguration)" />
      <MemberSignature Language="F#" Value="static member SetConfiguration : System.Data.Entity.DbConfiguration -&gt; unit" Usage="System.Data.Entity.DbConfiguration.SetConfiguration configuration" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="configuration" Type="System.Data.Entity.DbConfiguration" />
      </Parameters>
      <Docs>
        <param name="configuration">The instance of <see cref="T:System.Data.Entity.DbConfiguration" />.</param>
        <summary>
            The Singleton instance of <see cref="T:System.Data.Entity.DbConfiguration" /> for this app domain. This can be
            set at application start before any Entity Framework features have been used and afterwards
            should be treated as read-only.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetContextFactory">
      <MemberSignature Language="C#" Value="protected internal void SetContextFactory (Type contextType, Func&lt;System.Data.Entity.DbContext&gt; factory);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void SetContextFactory(class System.Type contextType, class System.Func`1&lt;class System.Data.Entity.DbContext&gt; factory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.DbConfiguration.SetContextFactory(System.Type,System.Func{System.Data.Entity.DbContext})" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub SetContextFactory (contextType As Type, factory As Func(Of DbContext))" />
      <MemberSignature Language="F#" Value="member this.SetContextFactory : Type * Func&lt;System.Data.Entity.DbContext&gt; -&gt; unit" Usage="dbConfiguration.SetContextFactory (contextType, factory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="contextType" Type="System.Type" />
        <Parameter Name="factory" Type="System.Func&lt;System.Data.Entity.DbContext&gt;" />
      </Parameters>
      <Docs>
        <param name="contextType">The context type for which the factory should be used.</param>
        <param name="factory">The delegate to use to create context instances.</param>
        <summary>
            Call this method from the constructor of a class derived from <see cref="T:System.Data.Entity.DbConfiguration" /> to set
            a factory to allow <see cref="T:System.Data.Entity.Infrastructure.DbContextInfo" /> to create instances of a context that does not have a public,
            parameterless constructor.
            </summary>
        <remarks>
            This is typically needed to allow design-time tools like Migrations or scaffolding code to use contexts that
            do not have public, parameterless constructors.
            This method is provided as a convenient and discoverable way to add configuration to the Entity Framework.
            Internally it works in the same way as using AddDependencyResolver to add an appropriate resolver for
            <see cref="T:System.Func`1" /> with the context <see cref="T:System.Type" /> as the key. This means that, if desired,
            the same functionality can be achieved using a custom resolver or a resolver backed by an
            Inversion-of-Control container.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetContextFactory&lt;TContext&gt;">
      <MemberSignature Language="C#" Value="protected internal void SetContextFactory&lt;TContext&gt; (Func&lt;TContext&gt; factory) where TContext : System.Data.Entity.DbContext;" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void SetContextFactory&lt;(class System.Data.Entity.DbContext) TContext&gt;(class System.Func`1&lt;!!TContext&gt; factory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.DbConfiguration.SetContextFactory``1(System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub SetContextFactory(Of TContext As DbContext) (factory As Func(Of TContext))" />
      <MemberSignature Language="F#" Value="member this.SetContextFactory : Func&lt;'Context (requires 'Context :&gt; System.Data.Entity.DbContext)&gt; -&gt; unit (requires 'Context :&gt; System.Data.Entity.DbContext)" Usage="dbConfiguration.SetContextFactory factory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TContext">
          <Constraints>
            <BaseTypeName>System.Data.Entity.DbContext</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="factory" Type="System.Func&lt;TContext&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TContext">The context type for which the factory should be used.</typeparam>
        <param name="factory">The delegate to use to create context instances.</param>
        <summary>
            Call this method from the constructor of a class derived from <see cref="T:System.Data.Entity.DbConfiguration" /> to set
            a factory to allow <see cref="T:System.Data.Entity.Infrastructure.DbContextInfo" /> to create instances of a context that does not have a public,
            parameterless constructor.
            </summary>
        <remarks>
            This is typically needed to allow design-time tools like Migrations or scaffolding code to use contexts that
            do not have public, parameterless constructors.
            This method is provided as a convenient and discoverable way to add configuration to the Entity Framework.
            Internally it works in the same way as using AddDependencyResolver to add an appropriate resolver for
            <see cref="T:System.Func`1" /> with the context <see cref="T:System.Type" /> as the key. This means that, if desired,
            the same functionality can be achieved using a custom resolver or a resolver backed by an
            Inversion-of-Control container.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetDatabaseInitializer&lt;TContext&gt;">
      <MemberSignature Language="C#" Value="protected internal void SetDatabaseInitializer&lt;TContext&gt; (System.Data.Entity.IDatabaseInitializer&lt;TContext&gt; initializer) where TContext : System.Data.Entity.DbContext;" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void SetDatabaseInitializer&lt;(class System.Data.Entity.DbContext) TContext&gt;(class System.Data.Entity.IDatabaseInitializer`1&lt;!!TContext&gt; initializer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.DbConfiguration.SetDatabaseInitializer``1(System.Data.Entity.IDatabaseInitializer{``0})" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub SetDatabaseInitializer(Of TContext As DbContext) (initializer As IDatabaseInitializer(Of TContext))" />
      <MemberSignature Language="F#" Value="member this.SetDatabaseInitializer : System.Data.Entity.IDatabaseInitializer&lt;'Context (requires 'Context :&gt; System.Data.Entity.DbContext)&gt; -&gt; unit (requires 'Context :&gt; System.Data.Entity.DbContext)" Usage="dbConfiguration.SetDatabaseInitializer initializer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TContext">
          <Constraints>
            <BaseTypeName>System.Data.Entity.DbContext</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="initializer" Type="System.Data.Entity.IDatabaseInitializer&lt;TContext&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TContext"> The type of the context. </typeparam>
        <param name="initializer"> The initializer to use, or null to disable initialization for the given context type. </param>
        <summary>
            Call this method from the constructor of a class derived from <see cref="T:System.Data.Entity.DbConfiguration" /> to
            set the database initializer to use for the given context type.  The database initializer is called when a
            the given <see cref="T:System.Data.Entity.DbContext" /> type is used to access a database for the first time.
            The default strategy for Code First contexts is an instance of <see cref="T:System.Data.Entity.CreateDatabaseIfNotExists`1" />.
            </summary>
        <remarks>
            Calling this method is equivalent to calling <see cref="M:System.Data.Entity.Database.SetInitializer``1(System.Data.Entity.IDatabaseInitializer{``0})" />.
            This method is provided as a convenient and discoverable way to add configuration to the Entity Framework.
            Internally it works in the same way as using AddDependencyResolver to add an appropriate resolver for
            <see cref="T:System.Data.Entity.IDatabaseInitializer`1" />. This means that, if desired, the same functionality can be achieved using
            a custom resolver or a resolver backed by an Inversion-of-Control container.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetDatabaseLogFormatter">
      <MemberSignature Language="C#" Value="protected internal void SetDatabaseLogFormatter (Func&lt;System.Data.Entity.DbContext,Action&lt;string&gt;,System.Data.Entity.Infrastructure.Interception.DatabaseLogFormatter&gt; logFormatterFactory);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void SetDatabaseLogFormatter(class System.Func`3&lt;class System.Data.Entity.DbContext, class System.Action`1&lt;string&gt;, class System.Data.Entity.Infrastructure.Interception.DatabaseLogFormatter&gt; logFormatterFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.DbConfiguration.SetDatabaseLogFormatter(System.Func{System.Data.Entity.DbContext,System.Action{System.String},System.Data.Entity.Infrastructure.Interception.DatabaseLogFormatter})" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub SetDatabaseLogFormatter (logFormatterFactory As Func(Of DbContext, Action(Of String), DatabaseLogFormatter))" />
      <MemberSignature Language="F#" Value="member this.SetDatabaseLogFormatter : Func&lt;System.Data.Entity.DbContext, Action&lt;string&gt;, System.Data.Entity.Infrastructure.Interception.DatabaseLogFormatter&gt; -&gt; unit" Usage="dbConfiguration.SetDatabaseLogFormatter logFormatterFactory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logFormatterFactory" Type="System.Func&lt;System.Data.Entity.DbContext,System.Action&lt;System.String&gt;,System.Data.Entity.Infrastructure.Interception.DatabaseLogFormatter&gt;" />
      </Parameters>
      <Docs>
        <param name="logFormatterFactory">A delegate that will create formatter instances.</param>
        <summary>
            Call this method from the constructor of a class derived from <see cref="T:System.Data.Entity.DbConfiguration" /> to set
            a factory for the type of <see cref="T:System.Data.Entity.Infrastructure.Interception.DatabaseLogFormatter" /> to use with <see cref="P:System.Data.Entity.Database.Log" />.
            </summary>
        <remarks>
            Note that setting the type of formatter to use with this method does change the way command are
            logged when <see cref="P:System.Data.Entity.Database.Log" /> is used. It is still necessary to set a <see cref="T:System.IO.TextWriter" />
            instance onto <see cref="P:System.Data.Entity.Database.Log" /> before any commands will be logged.
            For more low-level control over logging/interception see <see cref="T:System.Data.Entity.Infrastructure.Interception.IDbCommandInterceptor" /> and
            <see cref="T:System.Data.Entity.Infrastructure.Interception.DbInterception" />.
            This method is provided as a convenient and discoverable way to add configuration to the Entity Framework.
            Internally it works in the same way as using AddDependencyResolver to add an appropriate resolver for
            <see cref="T:System.Func`1" />. This means that, if desired, the same functionality can be achieved using
            a custom resolver or a resolver backed by an Inversion-of-Control container.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetDefaultConnectionFactory">
      <MemberSignature Language="C#" Value="protected internal void SetDefaultConnectionFactory (System.Data.Entity.Infrastructure.IDbConnectionFactory connectionFactory);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void SetDefaultConnectionFactory(class System.Data.Entity.Infrastructure.IDbConnectionFactory connectionFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.DbConfiguration.SetDefaultConnectionFactory(System.Data.Entity.Infrastructure.IDbConnectionFactory)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub SetDefaultConnectionFactory (connectionFactory As IDbConnectionFactory)" />
      <MemberSignature Language="F#" Value="member this.SetDefaultConnectionFactory : System.Data.Entity.Infrastructure.IDbConnectionFactory -&gt; unit" Usage="dbConfiguration.SetDefaultConnectionFactory connectionFactory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="connectionFactory" Type="System.Data.Entity.Infrastructure.IDbConnectionFactory" />
      </Parameters>
      <Docs>
        <param name="connectionFactory"> The connection factory. </param>
        <summary>
            Sets the <see cref="T:System.Data.Entity.Infrastructure.IDbConnectionFactory" /> that is used to create connections by convention if no other
            connection string or connection is given to or can be discovered by <see cref="T:System.Data.Entity.DbContext" />.
            Note that a default connection factory is set in the app.config or web.config file whenever the
            EntityFramework NuGet package is installed. As for all config file settings, the default connection factory
            set in the config file will take precedence over any setting made with this method. Therefore the setting
            must be removed from the config file before calling this method will have any effect.
            Call this method from the constructor of a class derived from <see cref="T:System.Data.Entity.DbConfiguration" /> to change
            the default connection factory being used.
            </summary>
        <remarks>
            This method is provided as a convenient and discoverable way to add configuration to the Entity Framework.
            Internally it works in the same way as using AddDependencyResolver to add an appropriate resolver for
            <see cref="T:System.Data.Entity.Infrastructure.IDbConnectionFactory" />. This means that, if desired, the same functionality can be achieved using
            a custom resolver or a resolver backed by an Inversion-of-Control container.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetDefaultHistoryContext">
      <MemberSignature Language="C#" Value="protected internal void SetDefaultHistoryContext (Func&lt;System.Data.Common.DbConnection,string,System.Data.Entity.Migrations.History.HistoryContext&gt; factory);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void SetDefaultHistoryContext(class System.Func`3&lt;class System.Data.Common.DbConnection, string, class System.Data.Entity.Migrations.History.HistoryContext&gt; factory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.DbConfiguration.SetDefaultHistoryContext(System.Func{System.Data.Common.DbConnection,System.String,System.Data.Entity.Migrations.History.HistoryContext})" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub SetDefaultHistoryContext (factory As Func(Of DbConnection, String, HistoryContext))" />
      <MemberSignature Language="F#" Value="member this.SetDefaultHistoryContext : Func&lt;System.Data.Common.DbConnection, string, System.Data.Entity.Migrations.History.HistoryContext&gt; -&gt; unit" Usage="dbConfiguration.SetDefaultHistoryContext factory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="factory" Type="System.Func&lt;System.Data.Common.DbConnection,System.String,System.Data.Entity.Migrations.History.HistoryContext&gt;" />
      </Parameters>
      <Docs>
        <param name="factory"> 
            A factory for creating <see cref="T:System.Data.Entity.Migrations.History.HistoryContext" /> instances for a given <see cref="T:System.Data.Common.DbConnection" /> and
            <see cref="T:System.String" /> representing the default schema.
            </param>
        <summary>
            Call this method from the constructor of a class derived from <see cref="T:System.Data.Entity.DbConfiguration" /> to set
            a <see cref="T:System.Func`3" /> delegate which which be used for 
            creation of the default  <see cref="T:System.Data.Entity.Migrations.History.HistoryContext" /> for a any
            <see cref="T:System.Data.Entity.Migrations.DbMigrationsConfiguration" />. This default factory will only be used if no factory is
            set explicitly in the <see cref="T:System.Data.Entity.Migrations.DbMigrationsConfiguration" /> and if no factory has been registered
            for the provider in use using the
            <see cref="M:System.Data.Entity.DbConfiguration.SetHistoryContext(System.String,System.Func{System.Data.Common.DbConnection,System.String,System.Data.Entity.Migrations.History.HistoryContext})" />
            method.
            </summary>
        <remarks>
            This method is provided as a convenient and discoverable way to add configuration to the Entity Framework.
            Internally it works in the same way as using AddDependencyResolver to add an appropriate resolver for
            <see cref="T:System.Func`3" />. This means that, if desired, the same functionality
            can be achieved using a custom resolver or a resolver backed by an Inversion-of-Control container.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetDefaultSpatialServices">
      <MemberSignature Language="C#" Value="protected internal void SetDefaultSpatialServices (System.Data.Entity.Spatial.DbSpatialServices spatialProvider);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void SetDefaultSpatialServices(class System.Data.Entity.Spatial.DbSpatialServices spatialProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.DbConfiguration.SetDefaultSpatialServices(System.Data.Entity.Spatial.DbSpatialServices)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub SetDefaultSpatialServices (spatialProvider As DbSpatialServices)" />
      <MemberSignature Language="F#" Value="member this.SetDefaultSpatialServices : System.Data.Entity.Spatial.DbSpatialServices -&gt; unit" Usage="dbConfiguration.SetDefaultSpatialServices spatialProvider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="spatialProvider" Type="System.Data.Entity.Spatial.DbSpatialServices" />
      </Parameters>
      <Docs>
        <param name="spatialProvider"> The spatial provider. </param>
        <summary>
            Call this method from the constructor of a class derived from <see cref="T:System.Data.Entity.DbConfiguration" /> to set
            the global instance of <see cref="T:System.Data.Entity.Spatial.DbSpatialServices" /> which will be used whenever a spatial provider is
            required and a provider-specific spatial provider cannot be found. Normally, a provider-specific spatial provider
            is obtained from the a <see cref="T:System.Data.Entity.Core.Common.DbProviderServices" /> implementation which is in turn returned by resolving
            a service for <see cref="T:System.Data.Entity.Spatial.DbSpatialServices" /> passing the provider invariant name as a key. However, this
            cannot work for stand-alone instances of <see cref="T:System.Data.Entity.Spatial.DbGeometry" /> and <see cref="T:System.Data.Entity.Spatial.DbGeography" /> since
            it is impossible to know the spatial provider to use. Therefore, when creating stand-alone instances
            of <see cref="T:System.Data.Entity.Spatial.DbGeometry" /> and <see cref="T:System.Data.Entity.Spatial.DbGeography" /> the global spatial provider is always used.
            </summary>
        <remarks>
            This method is provided as a convenient and discoverable way to add configuration to the Entity Framework.
            Internally it works in the same way as using AddDependencyResolver to add an appropriate resolver for
            <see cref="T:System.Data.Entity.Spatial.DbSpatialServices" />. This means that, if desired, the same functionality can be achieved using
            a custom resolver or a resolver backed by an Inversion-of-Control container.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetDefaultTransactionHandler">
      <MemberSignature Language="C#" Value="protected internal void SetDefaultTransactionHandler (Func&lt;System.Data.Entity.Infrastructure.TransactionHandler&gt; transactionHandlerFactory);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void SetDefaultTransactionHandler(class System.Func`1&lt;class System.Data.Entity.Infrastructure.TransactionHandler&gt; transactionHandlerFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.DbConfiguration.SetDefaultTransactionHandler(System.Func{System.Data.Entity.Infrastructure.TransactionHandler})" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub SetDefaultTransactionHandler (transactionHandlerFactory As Func(Of TransactionHandler))" />
      <MemberSignature Language="F#" Value="member this.SetDefaultTransactionHandler : Func&lt;System.Data.Entity.Infrastructure.TransactionHandler&gt; -&gt; unit" Usage="dbConfiguration.SetDefaultTransactionHandler transactionHandlerFactory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionHandlerFactory" Type="System.Func&lt;System.Data.Entity.Infrastructure.TransactionHandler&gt;" />
      </Parameters>
      <Docs>
        <param name="transactionHandlerFactory"> A function that returns a new instance of a transaction handler. </param>
        <summary>
            Call this method from the constructor of a class derived from <see cref="T:System.Data.Entity.DbConfiguration" /> to register a
            <see cref="T:System.Data.Entity.Infrastructure.TransactionHandler" />.
            </summary>
        <remarks>
            This method is provided as a convenient and discoverable way to add configuration to the Entity Framework.
            Internally it works in the same way as using <see cref="M:System.Data.Entity.DbConfiguration.AddDependencyResolver(System.Data.Entity.Infrastructure.DependencyResolution.IDbDependencyResolver)" /> to add an appropriate resolver for
            <see cref="T:System.Data.Entity.Infrastructure.TransactionHandler" />. This means that, if desired, the same functionality can be achieved using
            a custom resolver or a resolver backed by an Inversion-of-Control container.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetExecutionStrategy">
      <MemberSignature Language="C#" Value="protected internal void SetExecutionStrategy (string providerInvariantName, Func&lt;System.Data.Entity.Infrastructure.IDbExecutionStrategy&gt; getExecutionStrategy);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void SetExecutionStrategy(string providerInvariantName, class System.Func`1&lt;class System.Data.Entity.Infrastructure.IDbExecutionStrategy&gt; getExecutionStrategy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.DbConfiguration.SetExecutionStrategy(System.String,System.Func{System.Data.Entity.Infrastructure.IDbExecutionStrategy})" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub SetExecutionStrategy (providerInvariantName As String, getExecutionStrategy As Func(Of IDbExecutionStrategy))" />
      <MemberSignature Language="F#" Value="member this.SetExecutionStrategy : string * Func&lt;System.Data.Entity.Infrastructure.IDbExecutionStrategy&gt; -&gt; unit" Usage="dbConfiguration.SetExecutionStrategy (providerInvariantName, getExecutionStrategy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="providerInvariantName" Type="System.String" />
        <Parameter Name="getExecutionStrategy" Type="System.Func&lt;System.Data.Entity.Infrastructure.IDbExecutionStrategy&gt;" />
      </Parameters>
      <Docs>
        <param name="providerInvariantName"> The ADO.NET provider invariant name indicating the type of ADO.NET connection for which this execution strategy will be used. </param>
        <param name="getExecutionStrategy"> A function that returns a new instance of an execution strategy. </param>
        <summary>
            Call this method from the constructor of a class derived from <see cref="T:System.Data.Entity.DbConfiguration" /> to register an
            <see cref="T:System.Data.Entity.Infrastructure.IDbExecutionStrategy" /> for use with the provider represented by the given invariant name.
            </summary>
        <remarks>
            This method is provided as a convenient and discoverable way to add configuration to the Entity Framework.
            Internally it works in the same way as using AddDependencyResolver to add an appropriate resolver for
            <see cref="T:System.Data.Entity.Infrastructure.IDbExecutionStrategy" />. This means that, if desired, the same functionality can be achieved using
            a custom resolver or a resolver backed by an Inversion-of-Control container.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetExecutionStrategy">
      <MemberSignature Language="C#" Value="protected internal void SetExecutionStrategy (string providerInvariantName, Func&lt;System.Data.Entity.Infrastructure.IDbExecutionStrategy&gt; getExecutionStrategy, string serverName);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void SetExecutionStrategy(string providerInvariantName, class System.Func`1&lt;class System.Data.Entity.Infrastructure.IDbExecutionStrategy&gt; getExecutionStrategy, string serverName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.DbConfiguration.SetExecutionStrategy(System.String,System.Func{System.Data.Entity.Infrastructure.IDbExecutionStrategy},System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub SetExecutionStrategy (providerInvariantName As String, getExecutionStrategy As Func(Of IDbExecutionStrategy), serverName As String)" />
      <MemberSignature Language="F#" Value="member this.SetExecutionStrategy : string * Func&lt;System.Data.Entity.Infrastructure.IDbExecutionStrategy&gt; * string -&gt; unit" Usage="dbConfiguration.SetExecutionStrategy (providerInvariantName, getExecutionStrategy, serverName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="providerInvariantName" Type="System.String" />
        <Parameter Name="getExecutionStrategy" Type="System.Func&lt;System.Data.Entity.Infrastructure.IDbExecutionStrategy&gt;" />
        <Parameter Name="serverName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="providerInvariantName">
            The ADO.NET provider invariant name indicating the type of ADO.NET connection for which this execution strategy will be used.
            </param>
        <param name="getExecutionStrategy"> A function that returns a new instance of an execution strategy. </param>
        <param name="serverName"> A string that will be matched against the server name in the connection string. </param>
        <summary>
            Call this method from the constructor of a class derived from <see cref="T:System.Data.Entity.DbConfiguration" /> to register an
            <see cref="T:System.Data.Entity.Infrastructure.IDbExecutionStrategy" /> for use with the provider represented by the given invariant name and
            for a given server name.
            </summary>
        <remarks>
            This method is provided as a convenient and discoverable way to add configuration to the Entity Framework.
            Internally it works in the same way as using <see cref="M:System.Data.Entity.DbConfiguration.AddDependencyResolver(System.Data.Entity.Infrastructure.DependencyResolution.IDbDependencyResolver)" /> to add an appropriate resolver for
            <see cref="T:System.Data.Entity.Infrastructure.IDbExecutionStrategy" />. This means that, if desired, the same functionality can be achieved using
            a custom resolver or a resolver backed by an Inversion-of-Control container.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetHistoryContext">
      <MemberSignature Language="C#" Value="protected internal void SetHistoryContext (string providerInvariantName, Func&lt;System.Data.Common.DbConnection,string,System.Data.Entity.Migrations.History.HistoryContext&gt; factory);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void SetHistoryContext(string providerInvariantName, class System.Func`3&lt;class System.Data.Common.DbConnection, string, class System.Data.Entity.Migrations.History.HistoryContext&gt; factory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.DbConfiguration.SetHistoryContext(System.String,System.Func{System.Data.Common.DbConnection,System.String,System.Data.Entity.Migrations.History.HistoryContext})" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub SetHistoryContext (providerInvariantName As String, factory As Func(Of DbConnection, String, HistoryContext))" />
      <MemberSignature Language="F#" Value="member this.SetHistoryContext : string * Func&lt;System.Data.Common.DbConnection, string, System.Data.Entity.Migrations.History.HistoryContext&gt; -&gt; unit" Usage="dbConfiguration.SetHistoryContext (providerInvariantName, factory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="providerInvariantName" Type="System.String" />
        <Parameter Name="factory" Type="System.Func&lt;System.Data.Common.DbConnection,System.String,System.Data.Entity.Migrations.History.HistoryContext&gt;" />
      </Parameters>
      <Docs>
        <param name="providerInvariantName"> The invariant name of the ADO.NET provider for which this generator should be used. </param>
        <param name="factory"> 
            A factory for creating <see cref="T:System.Data.Entity.Migrations.History.HistoryContext" /> instances for a given <see cref="T:System.Data.Common.DbConnection" /> and
            <see cref="T:System.String" /> representing the default schema.
            </param>
        <summary>
            Call this method from the constructor of a class derived from <see cref="T:System.Data.Entity.DbConfiguration" /> to set
            a <see cref="T:System.Func`3" /> delegate which allows for creation of a customized
            <see cref="T:System.Data.Entity.Migrations.History.HistoryContext" /> for the given provider for any <see cref="T:System.Data.Entity.Migrations.DbMigrationsConfiguration" /> 
            that does not have an explicit factory set.
            </summary>
        <remarks>
            This method is provided as a convenient and discoverable way to add configuration to the Entity Framework.
            Internally it works in the same way as using AddDependencyResolver to add an appropriate resolver for
            <see cref="T:System.Func`3" />. This means that, if desired, the same functionality
            can be achieved using a custom resolver or a resolver backed by an Inversion-of-Control container.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetManifestTokenResolver">
      <MemberSignature Language="C#" Value="protected internal void SetManifestTokenResolver (System.Data.Entity.Infrastructure.IManifestTokenResolver resolver);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void SetManifestTokenResolver(class System.Data.Entity.Infrastructure.IManifestTokenResolver resolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.DbConfiguration.SetManifestTokenResolver(System.Data.Entity.Infrastructure.IManifestTokenResolver)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub SetManifestTokenResolver (resolver As IManifestTokenResolver)" />
      <MemberSignature Language="F#" Value="member this.SetManifestTokenResolver : System.Data.Entity.Infrastructure.IManifestTokenResolver -&gt; unit" Usage="dbConfiguration.SetManifestTokenResolver resolver" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resolver" Type="System.Data.Entity.Infrastructure.IManifestTokenResolver" />
      </Parameters>
      <Docs>
        <param name="resolver"> The manifest token resolver. </param>
        <summary>
            Call this method from the constructor of a class derived from <see cref="T:System.Data.Entity.DbConfiguration" /> to set
            an implementation of <see cref="T:System.Data.Entity.Infrastructure.IManifestTokenResolver" /> which allows provider manifest tokens to
            be obtained from connections without necessarily opening the connection.
            </summary>
        <remarks>
            This method is provided as a convenient and discoverable way to add configuration to the Entity Framework.
            Internally it works in the same way as using AddDependencyResolver to add an appropriate resolver for
            <see cref="T:System.Data.Entity.Infrastructure.IManifestTokenResolver" />. This means that, if desired, the same functionality can be achieved using
            a custom resolver or a resolver backed by an Inversion-of-Control container.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetMetadataAnnotationSerializer">
      <MemberSignature Language="C#" Value="protected internal void SetMetadataAnnotationSerializer (string annotationName, Func&lt;System.Data.Entity.Infrastructure.IMetadataAnnotationSerializer&gt; serializerFactory);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void SetMetadataAnnotationSerializer(string annotationName, class System.Func`1&lt;class System.Data.Entity.Infrastructure.IMetadataAnnotationSerializer&gt; serializerFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.DbConfiguration.SetMetadataAnnotationSerializer(System.String,System.Func{System.Data.Entity.Infrastructure.IMetadataAnnotationSerializer})" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub SetMetadataAnnotationSerializer (annotationName As String, serializerFactory As Func(Of IMetadataAnnotationSerializer))" />
      <MemberSignature Language="F#" Value="member this.SetMetadataAnnotationSerializer : string * Func&lt;System.Data.Entity.Infrastructure.IMetadataAnnotationSerializer&gt; -&gt; unit" Usage="dbConfiguration.SetMetadataAnnotationSerializer (annotationName, serializerFactory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="annotationName" Type="System.String" />
        <Parameter Name="serializerFactory" Type="System.Func&lt;System.Data.Entity.Infrastructure.IMetadataAnnotationSerializer&gt;" />
      </Parameters>
      <Docs>
        <param name="annotationName"> The name of custom annotation that will be handled by this serializer. </param>
        <param name="serializerFactory"> A delegate that will be used to create serializer instances. </param>
        <summary>
            Call this method from the constructor of a class derived from <see cref="T:System.Data.Entity.DbConfiguration" /> to set
            a factory for implementations of <see cref="T:System.Data.Entity.Infrastructure.IMetadataAnnotationSerializer" /> which allows custom annotations
            represented by <see cref="T:System.Data.Entity.Core.Metadata.Edm.MetadataProperty" /> instances to be serialized to and from the EDMX XML.
            </summary>
        <remarks>
            Note that an <see cref="T:System.Func`1" /> is not needed if the annotation uses a simple string value.
            This method is provided as a convenient and discoverable way to add configuration to the Entity Framework.
            Internally it works in the same way as using AddDependencyResolver to add an appropriate resolver for
            <see cref="T:System.Data.Entity.Infrastructure.IMetadataAnnotationSerializer" />. This means that, if desired, the same functionality can be achieved using
            a custom resolver or a resolver backed by an Inversion-of-Control container.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetMigrationSqlGenerator">
      <MemberSignature Language="C#" Value="protected internal void SetMigrationSqlGenerator (string providerInvariantName, Func&lt;System.Data.Entity.Migrations.Sql.MigrationSqlGenerator&gt; sqlGenerator);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void SetMigrationSqlGenerator(string providerInvariantName, class System.Func`1&lt;class System.Data.Entity.Migrations.Sql.MigrationSqlGenerator&gt; sqlGenerator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.DbConfiguration.SetMigrationSqlGenerator(System.String,System.Func{System.Data.Entity.Migrations.Sql.MigrationSqlGenerator})" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub SetMigrationSqlGenerator (providerInvariantName As String, sqlGenerator As Func(Of MigrationSqlGenerator))" />
      <MemberSignature Language="F#" Value="member this.SetMigrationSqlGenerator : string * Func&lt;System.Data.Entity.Migrations.Sql.MigrationSqlGenerator&gt; -&gt; unit" Usage="dbConfiguration.SetMigrationSqlGenerator (providerInvariantName, sqlGenerator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="providerInvariantName" Type="System.String" />
        <Parameter Name="sqlGenerator" Type="System.Func&lt;System.Data.Entity.Migrations.Sql.MigrationSqlGenerator&gt;" />
      </Parameters>
      <Docs>
        <param name="providerInvariantName"> The invariant name of the ADO.NET provider for which this generator should be used. </param>
        <param name="sqlGenerator"> A delegate that returns a new instance of the SQL generator each time it is called. </param>
        <summary>
            Call this method from the constructor of a class derived from <see cref="T:System.Data.Entity.DbConfiguration" /> to register a
            <see cref="T:System.Data.Entity.Migrations.Sql.MigrationSqlGenerator" /> for use with the provider represented by the given invariant name.
            </summary>
        <remarks>
            This method is typically used by providers to register an associated SQL generator for Code First Migrations.
            It is different from setting the generator in the <see cref="T:System.Data.Entity.Migrations.DbMigrationsConfiguration" /> because it allows
            EF to use the Migrations pipeline to create a database even when there is no Migrations configuration in the project
            and/or Migrations are not being explicitly used.
            This method is provided as a convenient and discoverable way to add configuration to the Entity Framework.
            Internally it works in the same way as using AddDependencyResolver to add an appropriate resolver for
            <see cref="T:System.Data.Entity.Migrations.Sql.MigrationSqlGenerator" />. This means that, if desired, the same functionality can be achieved using
            a custom resolver or a resolver backed by an Inversion-of-Control container.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetModelCacheKey">
      <MemberSignature Language="C#" Value="protected internal void SetModelCacheKey (Func&lt;System.Data.Entity.DbContext,System.Data.Entity.Infrastructure.IDbModelCacheKey&gt; keyFactory);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void SetModelCacheKey(class System.Func`2&lt;class System.Data.Entity.DbContext, class System.Data.Entity.Infrastructure.IDbModelCacheKey&gt; keyFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.DbConfiguration.SetModelCacheKey(System.Func{System.Data.Entity.DbContext,System.Data.Entity.Infrastructure.IDbModelCacheKey})" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub SetModelCacheKey (keyFactory As Func(Of DbContext, IDbModelCacheKey))" />
      <MemberSignature Language="F#" Value="member this.SetModelCacheKey : Func&lt;System.Data.Entity.DbContext, System.Data.Entity.Infrastructure.IDbModelCacheKey&gt; -&gt; unit" Usage="dbConfiguration.SetModelCacheKey keyFactory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyFactory" Type="System.Func&lt;System.Data.Entity.DbContext,System.Data.Entity.Infrastructure.IDbModelCacheKey&gt;" />
      </Parameters>
      <Docs>
        <param name="keyFactory"> The key factory. </param>
        <summary>
            Call this method from the constructor of a class derived from <see cref="T:System.Data.Entity.DbConfiguration" /> to set
            a <see cref="T:System.Func`2" /> as the model cache key factory which allows the key
            used to cache the model behind a <see cref="T:System.Data.Entity.DbContext" /> to be changed.
            </summary>
        <remarks>
            This method is provided as a convenient and discoverable way to add configuration to the Entity Framework.
            Internally it works in the same way as using AddDependencyResolver to add an appropriate resolver for
            <see cref="T:System.Func`2" />. This means that, if desired, the same functionality can
            be achieved using a custom resolver or a resolver backed by an Inversion-of-Control container.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetModelStore">
      <MemberSignature Language="C#" Value="protected internal void SetModelStore (System.Data.Entity.Infrastructure.DbModelStore modelStore);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void SetModelStore(class System.Data.Entity.Infrastructure.DbModelStore modelStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.DbConfiguration.SetModelStore(System.Data.Entity.Infrastructure.DbModelStore)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub SetModelStore (modelStore As DbModelStore)" />
      <MemberSignature Language="F#" Value="member this.SetModelStore : System.Data.Entity.Infrastructure.DbModelStore -&gt; unit" Usage="dbConfiguration.SetModelStore modelStore" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="modelStore" Type="System.Data.Entity.Infrastructure.DbModelStore" />
      </Parameters>
      <Docs>
        <param name="modelStore">The model store implementation.</param>
        <summary>
            Sets a singleton model store implementation (persisted model cache).
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetPluralizationService">
      <MemberSignature Language="C#" Value="protected internal void SetPluralizationService (System.Data.Entity.Infrastructure.Pluralization.IPluralizationService pluralizationService);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void SetPluralizationService(class System.Data.Entity.Infrastructure.Pluralization.IPluralizationService pluralizationService) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.DbConfiguration.SetPluralizationService(System.Data.Entity.Infrastructure.Pluralization.IPluralizationService)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub SetPluralizationService (pluralizationService As IPluralizationService)" />
      <MemberSignature Language="F#" Value="member this.SetPluralizationService : System.Data.Entity.Infrastructure.Pluralization.IPluralizationService -&gt; unit" Usage="dbConfiguration.SetPluralizationService pluralizationService" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId="pluralization")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId="Pluralization")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pluralizationService" Type="System.Data.Entity.Infrastructure.Pluralization.IPluralizationService" />
      </Parameters>
      <Docs>
        <param name="pluralizationService"> The pluralization service to use. </param>
        <summary>
            Call this method from the constructor of a class derived from <see cref="T:System.Data.Entity.DbConfiguration" /> to
            set the pluralization service.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetProviderFactory">
      <MemberSignature Language="C#" Value="protected internal void SetProviderFactory (string providerInvariantName, System.Data.Common.DbProviderFactory providerFactory);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void SetProviderFactory(string providerInvariantName, class System.Data.Common.DbProviderFactory providerFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.DbConfiguration.SetProviderFactory(System.String,System.Data.Common.DbProviderFactory)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub SetProviderFactory (providerInvariantName As String, providerFactory As DbProviderFactory)" />
      <MemberSignature Language="F#" Value="member this.SetProviderFactory : string * System.Data.Common.DbProviderFactory -&gt; unit" Usage="dbConfiguration.SetProviderFactory (providerInvariantName, providerFactory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="providerInvariantName" Type="System.String" />
        <Parameter Name="providerFactory" Type="System.Data.Common.DbProviderFactory" />
      </Parameters>
      <Docs>
        <param name="providerInvariantName"> The ADO.NET provider invariant name indicating the type of ADO.NET connection for which this provider will be used. </param>
        <param name="providerFactory"> The provider instance. </param>
        <summary>
            Call this method from the constructor of a class derived from <see cref="T:System.Data.Entity.DbConfiguration" /> to register
            an ADO.NET provider.
            </summary>
        <remarks>
            This method is provided as a convenient and discoverable way to add configuration to the Entity Framework.
            Internally it works in the same way as using AddDependencyResolver to add an appropriate resolvers for
            <see cref="T:System.Data.Common.DbProviderFactory" /> and <see cref="T:System.Data.Entity.Infrastructure.IProviderInvariantName" />. This means that, if desired,
            the same functionality can be achieved using a custom resolver or a resolver backed by an
            Inversion-of-Control container.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetProviderFactoryResolver">
      <MemberSignature Language="C#" Value="protected internal void SetProviderFactoryResolver (System.Data.Entity.Infrastructure.IDbProviderFactoryResolver providerFactoryResolver);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void SetProviderFactoryResolver(class System.Data.Entity.Infrastructure.IDbProviderFactoryResolver providerFactoryResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.DbConfiguration.SetProviderFactoryResolver(System.Data.Entity.Infrastructure.IDbProviderFactoryResolver)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub SetProviderFactoryResolver (providerFactoryResolver As IDbProviderFactoryResolver)" />
      <MemberSignature Language="F#" Value="member this.SetProviderFactoryResolver : System.Data.Entity.Infrastructure.IDbProviderFactoryResolver -&gt; unit" Usage="dbConfiguration.SetProviderFactoryResolver providerFactoryResolver" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="providerFactoryResolver" Type="System.Data.Entity.Infrastructure.IDbProviderFactoryResolver" />
      </Parameters>
      <Docs>
        <param name="providerFactoryResolver"> The provider factory service. </param>
        <summary>
            Call this method from the constructor of a class derived from <see cref="T:System.Data.Entity.DbConfiguration" /> to set
            an implementation of <see cref="T:System.Data.Entity.Infrastructure.IDbProviderFactoryResolver" /> which allows a <see cref="T:System.Data.Common.DbProviderFactory" />
            to be obtained from a <see cref="T:System.Data.Common.DbConnection" /> in cases where the default implementation is not
            sufficient.
            </summary>
        <remarks>
            This method is provided as a convenient and discoverable way to add configuration to the Entity Framework.
            Internally it works in the same way as using AddDependencyResolver to add an appropriate resolver for
            <see cref="T:System.Data.Entity.Infrastructure.IDbProviderFactoryResolver" />. This means that, if desired, the same functionality can be achieved using
            a custom resolver or a resolver backed by an Inversion-of-Control container.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetProviderServices">
      <MemberSignature Language="C#" Value="protected internal void SetProviderServices (string providerInvariantName, System.Data.Entity.Core.Common.DbProviderServices provider);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void SetProviderServices(string providerInvariantName, class System.Data.Entity.Core.Common.DbProviderServices provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.DbConfiguration.SetProviderServices(System.String,System.Data.Entity.Core.Common.DbProviderServices)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub SetProviderServices (providerInvariantName As String, provider As DbProviderServices)" />
      <MemberSignature Language="F#" Value="member this.SetProviderServices : string * System.Data.Entity.Core.Common.DbProviderServices -&gt; unit" Usage="dbConfiguration.SetProviderServices (providerInvariantName, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="providerInvariantName" Type="System.String" />
        <Parameter Name="provider" Type="System.Data.Entity.Core.Common.DbProviderServices" />
      </Parameters>
      <Docs>
        <param name="providerInvariantName"> The ADO.NET provider invariant name indicating the type of ADO.NET connection for which this provider will be used. </param>
        <param name="provider"> The provider instance. </param>
        <summary>
            Call this method from the constructor of a class derived from <see cref="T:System.Data.Entity.DbConfiguration" /> to register
            an Entity Framework provider.
            </summary>
        <remarks>
            Note that the provider is both registered as a service itself and also registered as a default resolver with
            a call to AddDefaultResolver.  This allows EF providers to act as resolvers for other services that
            may need to be overridden by the provider.
            This method is provided as a convenient and discoverable way to add configuration to the Entity Framework.
            Internally it works in the same way as using AddDependencyResolver to add an appropriate resolver for
            <see cref="T:System.Data.Entity.Core.Common.DbProviderServices" /> and also using AddDefaultResolver to add the provider as a default
            resolver. This means that, if desired, the same functionality can be achieved using a custom resolver or a
            resolver backed by an Inversion-of-Control container.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSpatialServices">
      <MemberSignature Language="C#" Value="protected internal void SetSpatialServices (System.Data.Entity.Infrastructure.DbProviderInfo key, System.Data.Entity.Spatial.DbSpatialServices spatialProvider);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void SetSpatialServices(class System.Data.Entity.Infrastructure.DbProviderInfo key, class System.Data.Entity.Spatial.DbSpatialServices spatialProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.DbConfiguration.SetSpatialServices(System.Data.Entity.Infrastructure.DbProviderInfo,System.Data.Entity.Spatial.DbSpatialServices)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub SetSpatialServices (key As DbProviderInfo, spatialProvider As DbSpatialServices)" />
      <MemberSignature Language="F#" Value="member this.SetSpatialServices : System.Data.Entity.Infrastructure.DbProviderInfo * System.Data.Entity.Spatial.DbSpatialServices -&gt; unit" Usage="dbConfiguration.SetSpatialServices (key, spatialProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Data.Entity.Infrastructure.DbProviderInfo" />
        <Parameter Name="spatialProvider" Type="System.Data.Entity.Spatial.DbSpatialServices" />
      </Parameters>
      <Docs>
        <param name="key">
            The <see cref="T:System.Data.Entity.Infrastructure.DbProviderInfo" /> indicating the type of ADO.NET connection for which this spatial provider will be used.
            </param>
        <param name="spatialProvider"> The spatial provider. </param>
        <summary>
            Call this method from the constructor of a class derived from <see cref="T:System.Data.Entity.DbConfiguration" /> to set
            an implementation of <see cref="T:System.Data.Entity.Spatial.DbSpatialServices" /> to use for a specific provider and provider
            manifest token.
            </summary>
        <remarks>
            Use <see cref="M:System.Data.Entity.DbConfiguration.SetSpatialServices(System.Data.Entity.Infrastructure.DbProviderInfo,System.Data.Entity.Spatial.DbSpatialServices)" />
            to register spatial services for use only when a specific manifest token is returned by the provider.
            Use <see cref="M:System.Data.Entity.DbConfiguration.SetDefaultSpatialServices(System.Data.Entity.Spatial.DbSpatialServices)" /> to register global
            spatial services to be used when provider information is not available or no provider-specific
            spatial services are found.
            This method is provided as a convenient and discoverable way to add configuration to the Entity Framework.
            Internally it works in the same way as using AddDependencyResolver to add an appropriate resolver for
            <see cref="T:System.Data.Entity.Spatial.DbSpatialServices" />. This means that, if desired, the same functionality can be achieved using
            a custom resolver or a resolver backed by an Inversion-of-Control container.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSpatialServices">
      <MemberSignature Language="C#" Value="protected internal void SetSpatialServices (string providerInvariantName, System.Data.Entity.Spatial.DbSpatialServices spatialProvider);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void SetSpatialServices(string providerInvariantName, class System.Data.Entity.Spatial.DbSpatialServices spatialProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.DbConfiguration.SetSpatialServices(System.String,System.Data.Entity.Spatial.DbSpatialServices)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub SetSpatialServices (providerInvariantName As String, spatialProvider As DbSpatialServices)" />
      <MemberSignature Language="F#" Value="member this.SetSpatialServices : string * System.Data.Entity.Spatial.DbSpatialServices -&gt; unit" Usage="dbConfiguration.SetSpatialServices (providerInvariantName, spatialProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="providerInvariantName" Type="System.String" />
        <Parameter Name="spatialProvider" Type="System.Data.Entity.Spatial.DbSpatialServices" />
      </Parameters>
      <Docs>
        <param name="providerInvariantName"> The ADO.NET provider invariant name indicating the type of ADO.NET connection for which this spatial provider will be used. </param>
        <param name="spatialProvider"> The spatial provider. </param>
        <summary>
            Call this method from the constructor of a class derived from <see cref="T:System.Data.Entity.DbConfiguration" /> to set
            an implementation of <see cref="T:System.Data.Entity.Spatial.DbSpatialServices" /> to use for a specific provider with any
            manifest token.
            </summary>
        <remarks>
            Use <see cref="M:System.Data.Entity.DbConfiguration.SetSpatialServices(System.String,System.Data.Entity.Spatial.DbSpatialServices)" /> 
            to register spatial services for use when any manifest token is returned by the provider.
            Use <see cref="M:System.Data.Entity.DbConfiguration.SetDefaultSpatialServices(System.Data.Entity.Spatial.DbSpatialServices)" /> to register global
            spatial services to be used when provider information is not available or no provider-specific
            spatial services are found.
            
            This method is provided as a convenient and discoverable way to add configuration to the Entity Framework.
            Internally it works in the same way as using AddDependencyResolver to add an appropriate resolver for
            <see cref="T:System.Data.Entity.Spatial.DbSpatialServices" />. This means that, if desired, the same functionality can be achieved using
            a custom resolver or a resolver backed by an Inversion-of-Control container.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTableExistenceChecker">
      <MemberSignature Language="C#" Value="protected internal void SetTableExistenceChecker (string providerInvariantName, System.Data.Entity.Infrastructure.TableExistenceChecker tableExistenceChecker);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void SetTableExistenceChecker(string providerInvariantName, class System.Data.Entity.Infrastructure.TableExistenceChecker tableExistenceChecker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.DbConfiguration.SetTableExistenceChecker(System.String,System.Data.Entity.Infrastructure.TableExistenceChecker)" />
      <MemberSignature Language="F#" Value="member this.SetTableExistenceChecker : string * System.Data.Entity.Infrastructure.TableExistenceChecker -&gt; unit" Usage="dbConfiguration.SetTableExistenceChecker (providerInvariantName, tableExistenceChecker)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="providerInvariantName" Type="System.String" />
        <Parameter Name="tableExistenceChecker" Type="System.Data.Entity.Infrastructure.TableExistenceChecker" />
      </Parameters>
      <Docs>
        <param name="providerInvariantName"> The ADO.NET provider invariant name indicating the type of ADO.NET connection for which this provider will be used. </param>
        <param name="tableExistenceChecker"> The table existence checker to use. </param>
        <summary>
            Call this method from the constructor of a class derived from <see cref="T:System.Data.Entity.DbConfiguration" /> to register
            a database table existence checker for a given provider.
            </summary>
        <remarks>
            This method is provided as a convenient and discoverable way to add configuration to the Entity Framework.
            Internally it works in the same way as using AddDependencyResolver to add an appropriate resolver for
            <see cref="T:System.Data.Entity.Core.Common.DbProviderServices" /> and also using AddDefaultResolver to add the provider as a default
            resolver. This means that, if desired, the same functionality can be achieved using a custom resolver or a
            resolver backed by an Inversion-of-Control container.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTransactionHandler">
      <MemberSignature Language="C#" Value="protected internal void SetTransactionHandler (string providerInvariantName, Func&lt;System.Data.Entity.Infrastructure.TransactionHandler&gt; transactionHandlerFactory);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void SetTransactionHandler(string providerInvariantName, class System.Func`1&lt;class System.Data.Entity.Infrastructure.TransactionHandler&gt; transactionHandlerFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.DbConfiguration.SetTransactionHandler(System.String,System.Func{System.Data.Entity.Infrastructure.TransactionHandler})" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub SetTransactionHandler (providerInvariantName As String, transactionHandlerFactory As Func(Of TransactionHandler))" />
      <MemberSignature Language="F#" Value="member this.SetTransactionHandler : string * Func&lt;System.Data.Entity.Infrastructure.TransactionHandler&gt; -&gt; unit" Usage="dbConfiguration.SetTransactionHandler (providerInvariantName, transactionHandlerFactory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="providerInvariantName" Type="System.String" />
        <Parameter Name="transactionHandlerFactory" Type="System.Func&lt;System.Data.Entity.Infrastructure.TransactionHandler&gt;" />
      </Parameters>
      <Docs>
        <param name="providerInvariantName">
            The ADO.NET provider invariant name indicating the type of ADO.NET connection for which this transaction handler will be used.
            </param>
        <param name="transactionHandlerFactory"> A function that returns a new instance of a transaction handler. </param>
        <summary>
            Call this method from the constructor of a class derived from <see cref="T:System.Data.Entity.DbConfiguration" /> to register a
            <see cref="T:System.Data.Entity.Infrastructure.TransactionHandler" /> for use with the provider represented by the given invariant name.
            </summary>
        <remarks>
            This method is provided as a convenient and discoverable way to add configuration to the Entity Framework.
            Internally it works in the same way as using <see cref="M:System.Data.Entity.DbConfiguration.AddDependencyResolver(System.Data.Entity.Infrastructure.DependencyResolution.IDbDependencyResolver)" /> to add an appropriate resolver for
            <see cref="T:System.Data.Entity.Infrastructure.TransactionHandler" />. This means that, if desired, the same functionality can be achieved using
            a custom resolver or a resolver backed by an Inversion-of-Control container.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTransactionHandler">
      <MemberSignature Language="C#" Value="protected internal void SetTransactionHandler (string providerInvariantName, Func&lt;System.Data.Entity.Infrastructure.TransactionHandler&gt; transactionHandlerFactory, string serverName);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void SetTransactionHandler(string providerInvariantName, class System.Func`1&lt;class System.Data.Entity.Infrastructure.TransactionHandler&gt; transactionHandlerFactory, string serverName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.DbConfiguration.SetTransactionHandler(System.String,System.Func{System.Data.Entity.Infrastructure.TransactionHandler},System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub SetTransactionHandler (providerInvariantName As String, transactionHandlerFactory As Func(Of TransactionHandler), serverName As String)" />
      <MemberSignature Language="F#" Value="member this.SetTransactionHandler : string * Func&lt;System.Data.Entity.Infrastructure.TransactionHandler&gt; * string -&gt; unit" Usage="dbConfiguration.SetTransactionHandler (providerInvariantName, transactionHandlerFactory, serverName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="providerInvariantName" Type="System.String" />
        <Parameter Name="transactionHandlerFactory" Type="System.Func&lt;System.Data.Entity.Infrastructure.TransactionHandler&gt;" />
        <Parameter Name="serverName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="providerInvariantName">
            The ADO.NET provider invariant name indicating the type of ADO.NET connection for which this transaction handler will be used.
            </param>
        <param name="transactionHandlerFactory"> A function that returns a new instance of a transaction handler. </param>
        <param name="serverName"> A string that will be matched against the server name in the connection string. </param>
        <summary>
            Call this method from the constructor of a class derived from <see cref="T:System.Data.Entity.DbConfiguration" /> to register a
            <see cref="T:System.Data.Entity.Infrastructure.TransactionHandler" /> for use with the provider represented by the given invariant name and
            for a given server name.
            </summary>
        <remarks>
            This method is provided as a convenient and discoverable way to add configuration to the Entity Framework.
            Internally it works in the same way as using <see cref="M:System.Data.Entity.DbConfiguration.AddDependencyResolver(System.Data.Entity.Infrastructure.DependencyResolution.IDbDependencyResolver)" /> to add an appropriate resolver for
            <see cref="T:System.Data.Entity.Infrastructure.TransactionHandler" />. This means that, if desired, the same functionality can be achieved using
            a custom resolver or a resolver backed by an Inversion-of-Control container.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.DbConfiguration.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dbConfiguration.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc />
      </Docs>
    </Member>
  </Members>
</Type>